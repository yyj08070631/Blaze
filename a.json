{"id":161018217,"type":"Doc","slug":"rih5mgvkl294kred","title":"位运算的算法应用","description":"位运算的算法应用基本介绍作为算法题的一个大类，位运算相关的题目常常出现在各大公司的面试/笔试题中，下面先说说位运算的基本原理。位运算使得计算机可以直接对每个比特位进行计算，效率会非常的高。在 JS 中，位运算会将操作数当作 32 位的二进制串进行计算，如果二进制串超过 32 位，则只保留最后的...","cover":"","user_id":125641,"book_id":37879881,"last_editor_id":125641,"format":"lake","body_draft":"<!doctype html><div class=\"lake-content\" typography=\"traditional\"><h1 id=\"sVa17\"><span class=\"ne-text\">位运算的算法应用</span></h1><h3 id=\"Iucu7\"><span class=\"ne-text\">基本介绍</span></h3><p id=\"u1c44377e\" class=\"ne-p\"><span class=\"ne-text\">作为算法题的一个大类，位运算相关的题目常常出现在各大公司的面试/笔试题中，下面先说说位运算的基本原理。</span></p><p id=\"ud4f433d3\" class=\"ne-p\"><br></p><p id=\"u8d638f3f\" class=\"ne-p\"><span class=\"ne-text\">位运算使得计算机可以直接对每个比特位进行计算，效率会非常的高。</span></p><p id=\"u8eaa65a5\" class=\"ne-p\"><br></p><p id=\"ub7943adc\" class=\"ne-p\"><span class=\"ne-text\">在 JS 中，位运算会将操作数当作 32 位的二进制串进行计算，如果二进制串超过 32 位，则只保留最后的 32 位进行计算，如：</span></p><pre data-language=\"bash\" id=\"SE8ru\" class=\"ne-codeblock language-bash\"><code>11100110111110100000000000000110000000000001 # 输入的二进制串\n            10100000000000000110000000000001 # 实际使用的二进制串</code></pre><p id=\"ud7b727ee\" class=\"ne-p\"><br></p><p id=\"u1861599c\" class=\"ne-p\"><span class=\"ne-text\">在 JS 中，位运算有 7 种运算符：</span></p><p id=\"uaa709a72\" class=\"ne-p\"><br></p><ol class=\"ne-ol\"><li id=\"u4f0e2f25\" data-lake-index-type=\"0\"><span class=\"ne-text\">按位与（a &amp; b）：在 a, b 的位表示中，每一个对应的位都为 1 则返回 1，否则返回 0</span></li></ol><pre data-language=\"bash\" id=\"Qkrsx\" class=\"ne-codeblock language-bash\"><code># 15 &amp; 9 -&gt; 9\n  0000 0000 0000 0000 0000 0000 0000 1111\n&amp; 0000 0000 0000 0000 0000 0000 0000 1001\n  ---------------------------------------\n  0000 0000 0000 0000 0000 0000 0000 1001</code></pre><p id=\"u16b492fd\" class=\"ne-p\"><br></p><ol start=\"2\" class=\"ne-ol\"><li id=\"u823ca447\" data-lake-index-type=\"0\"><span class=\"ne-text\">按位或（a | b）：在 a, b 的位表示中，每一个对应的位，只要有一个为 1 则返回 1，否则返回 0</span></li></ol><pre data-language=\"bash\" id=\"JTgrM\" class=\"ne-codeblock language-bash\"><code># 15 | 9 -&gt; 15\n  0000 0000 0000 0000 0000 0000 0000 1111\n| 0000 0000 0000 0000 0000 0000 0000 1001\n  ---------------------------------------\n  0000 0000 0000 0000 0000 0000 0000 1111</code></pre><p id=\"ue15e2835\" class=\"ne-p\"><br></p><ol start=\"3\" class=\"ne-ol\"><li id=\"ue71095b2\" data-lake-index-type=\"0\"><span class=\"ne-text\">按位异或（a ^ b）：在 a, b 的位表示中，每一个对应的位，两个不相同则返回 1，相同则返回 0</span></li></ol><pre data-language=\"bash\" id=\"AenYs\" class=\"ne-codeblock language-bash\"><code># 15 ^ 9 -&gt; 6\n  0000 0000 0000 0000 0000 0000 0000 1111\n| 0000 0000 0000 0000 0000 0000 0000 1001\n  ---------------------------------------\n  0000 0000 0000 0000 0000 0000 0000 0110</code></pre><p id=\"u91c29dcb\" class=\"ne-p\"><br></p><ol start=\"4\" class=\"ne-ol\"><li id=\"u684452ea\" data-lake-index-type=\"0\"><span class=\"ne-text\">按位非（~a）：反转被操作数的位，即将每一位的 0 转为 1，1 转为 0</span></li></ol><pre data-language=\"bash\" id=\"bSQvX\" class=\"ne-codeblock language-bash\"><code># ~15 -&gt; -16\n~ 0000 0000 0000 0000 0000 0000 0000 1111\n  ---------------------------------------\n  1111 1111 1111 1111 1111 1111 1111 0000</code></pre><p id=\"ufeab8f23\" class=\"ne-p\"><br></p><ol start=\"5\" class=\"ne-ol\"><li id=\"u0e14f280\" data-lake-index-type=\"0\"><span class=\"ne-text\">左移（a &lt;&lt; b）：将 a 的二进制串向左移动 b 位，右边移入 0</span></li></ol><pre data-language=\"bash\" id=\"wuNyp\" class=\"ne-codeblock language-bash\"><code># 9 &lt;&lt; 2 -&gt; 36\n&lt;&lt;  0000 0000 0000 0000 0000 0000 0000 1001\n    ---------------------------------------\n    0000 0000 0000 0000 0000 0000 0010 0100</code></pre><p id=\"u0545f9a9\" class=\"ne-p\"><br></p><p id=\"u0c06431d\" class=\"ne-p\"><span class=\"ne-text\">6. 有符号右移（a &gt;&gt; b）：把 a 的二进制表示向右移动 b 位，向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。这种右移由于保留最左侧的二进制位，因此可以保留数字原本的正负符号</span></p><pre data-language=\"bash\" id=\"zD0S8\" class=\"ne-codeblock language-bash\"><code># 9 &gt;&gt; 2 -&gt; 2\n&gt;&gt;  0000 0000 0000 0000 0000 0000 0000 1001\n    ---------------------------------------\n    0000 0000 0000 0000 0000 0000 0010 0010\n# -9 &gt;&gt; 2 -&gt; -3\n&gt;&gt;  1111 1111 1111 1111 1111 1111 1111 0111\n    ---------------------------------------\n    1111 1111 1111 1111 1111 1111 1111 1101</code></pre><p id=\"u79fd751e\" class=\"ne-p\"><br></p><p id=\"ud31e3f62\" class=\"ne-p\"><span class=\"ne-text\">7. 无符号右移（a &gt;&gt;&gt; b）：把 a 的二进制表示向右移动 b 位，向右被移出的位被丢弃，左边空出的位全部填充为 0。这种右移由于左侧直接补 0，因此生成的数字必然是非负数</span></p><pre data-language=\"bash\" id=\"SlQN1\" class=\"ne-codeblock language-bash\"><code># 19 &gt;&gt;&gt; 2 -&gt; 4\n&gt;&gt;&gt;  0000 0000 0000 0000 0000 0000 0001 0011\n     ---------------------------------------\n     0000 0000 0000 0000 0000 0000 0010 0010\n# -19 &gt;&gt;&gt; 2 -&gt; 1073741819\n&gt;&gt;&gt;  1111 1111 1111 1111 1111 1111 1110 1101\n     ---------------------------------------\n     0011 1111 1111 1111 1111 1111 1111 0011</code></pre><p id=\"ud0bf4c39\" class=\"ne-p\"><br></p><h3 id=\"xxuVW\"><span class=\"ne-text\">常用性质</span></h3><p id=\"u4d3a64fa\" class=\"ne-p\"><span class=\"ne-text\">在使用位运算技巧解的算法题中，有以下这些常用的性质：</span></p><p id=\"ubb626212\" class=\"ne-p\"><br></p><ol class=\"ne-ol\"><li id=\"u3fb5476e\" data-lake-index-type=\"0\"><span class=\"ne-text\">a 与自身之间的操作</span></li></ol><pre data-language=\"bash\" id=\"arLYF\" class=\"ne-codeblock language-bash\"><code>a &amp; a = a\na | a = a\na ^ a = 0</code></pre><p id=\"uff01915b\" class=\"ne-p\"><br></p><ol start=\"2\" class=\"ne-ol\"><li id=\"u411dd390\" data-lake-index-type=\"0\"><span class=\"ne-text\">a 与 0 之间的操作</span></li></ol><pre data-language=\"bash\" id=\"o3kc0\" class=\"ne-codeblock language-bash\"><code>a &amp; 0 = 0\na | 0 = a\na ^ 0 = a</code></pre><p id=\"u720b807a\" class=\"ne-p\"><br></p><ol start=\"3\" class=\"ne-ol\"><li id=\"ua0dd6598\" data-lake-index-type=\"0\"><span class=\"ne-text\">按位与、按位或的还原计算</span></li></ol><pre data-language=\"bash\" id=\"fuArK\" class=\"ne-codeblock language-bash\"><code>a | ( a &amp; b ) = a\na &amp; ( a | b ) = a</code></pre><p id=\"u251dc115\" class=\"ne-p\"><br></p><ol start=\"4\" class=\"ne-ol\"><li id=\"ubda7c069\" data-lake-index-type=\"0\"><span class=\"ne-text\">通过异或完成变量值交换</span></li></ol><pre data-language=\"bash\" id=\"Xn9kL\" class=\"ne-codeblock language-bash\"><code>a ^= b\nb ^= a\na ^= b</code></pre><p id=\"ub4ecd415\" class=\"ne-p\"><br></p><ol start=\"5\" class=\"ne-ol\"><li id=\"u7b658c74\" data-lake-index-type=\"0\"><span class=\"ne-text\">判断奇偶（通过 &amp; 1 取出最后一个二进制位以达到模 2 的效果）</span></li></ol><pre data-language=\"bash\" id=\"e6tTC\" class=\"ne-codeblock language-bash\"><code># 位运算效率更高\na &amp; 1 === a % 2</code></pre><p id=\"udc81b3b2\" class=\"ne-p\"><br></p><ol start=\"6\" class=\"ne-ol\"><li id=\"u47924ae6\" data-lake-index-type=\"0\"><span class=\"ne-text\">比较两值是否相等（a ^ a === 0）</span></li></ol><pre data-language=\"bash\" id=\"V0M5G\" class=\"ne-codeblock language-bash\"><code>a ^ b === 0</code></pre><p id=\"udd5fa9a3\" class=\"ne-p\"><br></p><ol start=\"7\" class=\"ne-ol\"><li id=\"u91fd07ef\" data-lake-index-type=\"0\"><span class=\"ne-text\">将第 i + 1 个二进制位设为 1</span></li></ol><pre data-language=\"bash\" id=\"ZdlbV\" class=\"ne-codeblock language-bash\"><code>a |= 1 &lt;&lt; i</code></pre><ol start=\"8\" class=\"ne-ol\"><li id=\"u1cf8c836\" data-lake-index-type=\"0\"><span class=\"ne-text\">将第 i + 1 个二进制位设为 0</span></li></ol><pre data-language=\"bash\" id=\"H6SAG\" class=\"ne-codeblock language-bash\"><code>a &amp;= ~(1 &lt;&lt; i)</code></pre><p id=\"u5b0c7c4a\" class=\"ne-p\"><br></p><ol start=\"9\" class=\"ne-ol\"><li id=\"u44880742\" data-lake-index-type=\"0\"><span class=\"ne-text\">取出第 i + 1 个二进制位上的数值</span></li></ol><pre data-language=\"bash\" id=\"mX0SU\" class=\"ne-codeblock language-bash\"><code>a &amp; (1 &lt;&lt; i)</code></pre><ol start=\"10\" class=\"ne-ol\"><li id=\"ua2c5ab02\" data-lake-index-type=\"0\"><span class=\"ne-text\">在 a 第 i + 1 个二进制位，插入 b 对应位置的二进制位</span></li></ol><pre data-language=\"bash\" id=\"TvVrJ\" class=\"ne-codeblock language-bash\"><code>a |= 1 &lt;&lt; i\na &amp; (b &amp; 1 &lt;&lt; i)</code></pre><p id=\"u40cc7c19\" class=\"ne-p\"><br></p><ol start=\"11\" class=\"ne-ol\"><li id=\"ub9c4a2f3\" data-lake-index-type=\"0\"><span class=\"ne-text\">删除二进制序列中最后一个值为 1 的位置</span></li></ol><pre data-language=\"bash\" id=\"X55hp\" class=\"ne-codeblock language-bash\"><code>a &amp;= (a - 1)</code></pre><p id=\"u9c58d752\" class=\"ne-p\"><br></p><ol start=\"12\" class=\"ne-ol\"><li id=\"ue8e8b963\" data-lake-index-type=\"0\"><span class=\"ne-text\">计算 a 的相反数</span></li></ol><pre data-language=\"bash\" id=\"YOdPx\" class=\"ne-codeblock language-bash\"><code>-a === ~a + 1</code></pre><p id=\"u4df312f9\" class=\"ne-p\"><br></p><ol start=\"13\" class=\"ne-ol\"><li id=\"ua40b55d2\" data-lake-index-type=\"0\"><span class=\"ne-text\">保留 a 在二进制位中最后一个 1</span></li></ol><pre data-language=\"bash\" id=\"oiVlA\" class=\"ne-codeblock language-bash\"><code>a &amp;= (-a)</code></pre><p id=\"u138fb043\" class=\"ne-p\"><br></p><ol start=\"14\" class=\"ne-ol\"><li id=\"u0d616c55\" data-lake-index-type=\"0\"><span class=\"ne-text\">生成二进制位全为 1 的数</span></li></ol><pre data-language=\"bash\" id=\"UhCrh\" class=\"ne-codeblock language-bash\"><code>~0</code></pre><p id=\"u5164dee9\" class=\"ne-p\"><br></p><ol start=\"15\" class=\"ne-ol\"><li id=\"u86ea175e\" data-lake-index-type=\"0\"><span class=\"ne-text\">保留 a 二进制序列中最后的 i - 1 位，其余补 0</span></li></ol><pre data-language=\"bash\" id=\"cFYLQ\" class=\"ne-codeblock language-bash\"><code>a &amp; ((1 &lt;&lt; i) - 1)</code></pre><p id=\"u5082250e\" class=\"ne-p\"><br></p><ol start=\"16\" class=\"ne-ol\"><li id=\"ud562b8fc\" data-lake-index-type=\"0\"><span class=\"ne-text\">将 a 二进制序列中最后 i - 1 位全部置为 0</span></li></ol><pre data-language=\"bash\" id=\"OTje2\" class=\"ne-codeblock language-bash\"><code>a &amp; ~((1 &lt;&lt; i) - 1)</code></pre><p id=\"ufe3f5669\" class=\"ne-p\"><br></p><ol start=\"17\" class=\"ne-ol\"><li id=\"uf8319894\" data-lake-index-type=\"0\"><span class=\"ne-text\">判断 a 的二进制序列最高位是否为 1</span></li></ol><pre data-language=\"bash\" id=\"y6jQN\" class=\"ne-codeblock language-bash\"><code>a &lt; 0 # 最高位为 1 必然是负数</code></pre><p id=\"u091c94b5\" class=\"ne-p\"><br></p><ol start=\"18\" class=\"ne-ol\"><li id=\"u0a84a17e\" data-lake-index-type=\"0\"><span class=\"ne-text\">在二进制序列中，仅保留最高位的 1，其他设为 0，输出该数</span></li></ol><pre data-language=\"bash\" id=\"HBNmB\" class=\"ne-codeblock language-bash\"><code>a = a | (a &gt;&gt; 1)\na = a | (a &gt;&gt; 2)\na = a | (a &gt;&gt; 4)\na = a | (a &gt;&gt; 8)\na = a | (a &gt;&gt; 16)\nreturn (a + 1) &gt;&gt; 1</code></pre><p id=\"u7beab1ae\" class=\"ne-p\"><br></p><p id=\"u30e1ff2b\" class=\"ne-p\"><span class=\"ne-text\">下面，我们通过一些简单-中等的题目来体验一下位运算解题的巧妙。</span></p><p id=\"u2bd5f4c2\" class=\"ne-p\"><br></p><h3 id=\"DROhD\"><span class=\"ne-text\">题目</span></h3><h4 id=\"dYkhm\"><span class=\"ne-text\">78 - 子集</span></h4><p id=\"u28281460\" class=\"ne-p\"><a href=\"https://leetcode-cn.com/problems/subsets\" data-href=\"https://leetcode-cn.com/problems/subsets\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">https://leetcode-cn.com/problems/subsets</span></a></p><p id=\"u974b951d\" class=\"ne-p\"><span class=\"ne-text\">给你一个整数数组 nums，数组中的元素</span><strong><span class=\"ne-text\">互不相同</span></strong><span class=\"ne-text\">。返回该数组所有可能的子集（幂集）。</span></p><p id=\"u71c7c1ac\" class=\"ne-p\"><span class=\"ne-text\">解集</span><strong><span class=\"ne-text\">不能</span></strong><span class=\"ne-text\">包含重复的子集。你可以按</span><strong><span class=\"ne-text\">任意顺序</span></strong><span class=\"ne-text\">返回解集。</span></p><p id=\"ub4b98bf4\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">示例 1：</span></strong></p><p id=\"u2eb03d60\" class=\"ne-p\"><strong><span class=\"ne-text\">输入：</span></strong><span class=\"ne-text\">nums = [1,2,3]<br /></span><strong><span class=\"ne-text\">输出：</span></strong><span class=\"ne-text\">[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span></p><p id=\"u3100fd7c\" class=\"ne-p\"><br></p><p id=\"u0d64c2a8\" class=\"ne-p\"><span class=\"ne-text\">从位运算出发去思考，如果用 0 和 1 标记一个数是否存在于子集中，这样列下来，例子中的输入 [1,2,3] 就会产生下表所示的子集与 0/1 序列的关系，因此我们可以直接遍历这个 0/1 序列，去构建每个子集的数据。</span></p><table id=\"DHpJx\" class=\"ne-table\" style=\"width: 750px\"><tbody><tr style=\"height: 34px\"><td width=\"250\"><p id=\"u44ddfc69\" class=\"ne-p\"><span class=\"ne-text\">0/1</span><span class=\"ne-text\">序列</span></p></td><td width=\"250\"><p id=\"u68745b77\" class=\"ne-p\"><span class=\"ne-text\">子集</span></p></td><td width=\"250\"><p id=\"ud4e486c9\" class=\"ne-p\"><span class=\"ne-text\">0/1</span><span class=\"ne-text\">序列对应的二进制数</span></p></td></tr><tr style=\"height: 34px\"><td width=\"250\"><p id=\"u3c293347\" class=\"ne-p\"><span class=\"ne-text\">000</span></p></td><td width=\"250\"><p id=\"ub69d191d\" class=\"ne-p\"><span class=\"ne-text\">{}</span></p></td><td width=\"250\"><p id=\"u9f3f53dc\" class=\"ne-p\"><span class=\"ne-text\">0</span></p></td></tr><tr style=\"height: 34px\"><td width=\"250\"><p id=\"u0c83a51a\" class=\"ne-p\"><span class=\"ne-text\">001</span></p></td><td width=\"250\"><p id=\"u7229159e\" class=\"ne-p\"><span class=\"ne-text\">{3}</span></p></td><td width=\"250\"><p id=\"uc4fe4cec\" class=\"ne-p\"><span class=\"ne-text\">1</span></p></td></tr><tr style=\"height: 34px\"><td width=\"250\"><p id=\"u6bd5ad2e\" class=\"ne-p\"><span class=\"ne-text\">010</span></p></td><td width=\"250\"><p id=\"u49b7605d\" class=\"ne-p\"><span class=\"ne-text\">{2}</span></p></td><td width=\"250\"><p id=\"uff04d3f3\" class=\"ne-p\"><span class=\"ne-text\">2</span></p></td></tr><tr style=\"height: 34px\"><td width=\"250\"><p id=\"u5ba058e4\" class=\"ne-p\"><span class=\"ne-text\">011</span></p></td><td width=\"250\"><p id=\"u9b8c0ab6\" class=\"ne-p\"><span class=\"ne-text\">{2,3}</span></p></td><td width=\"250\"><p id=\"u78be00ad\" class=\"ne-p\"><span class=\"ne-text\">3</span></p></td></tr><tr style=\"height: 34px\"><td width=\"250\"><p id=\"ueaab9f96\" class=\"ne-p\"><span class=\"ne-text\">100</span></p></td><td width=\"250\"><p id=\"u7dc131b4\" class=\"ne-p\"><span class=\"ne-text\">{1}</span></p></td><td width=\"250\"><p id=\"u11007ca1\" class=\"ne-p\"><span class=\"ne-text\">4</span></p></td></tr><tr style=\"height: 34px\"><td width=\"250\"><p id=\"u2a5a1c23\" class=\"ne-p\"><span class=\"ne-text\">101</span></p></td><td width=\"250\"><p id=\"u53cd3516\" class=\"ne-p\"><span class=\"ne-text\">{1,3}</span></p></td><td width=\"250\"><p id=\"u2ad32c76\" class=\"ne-p\"><span class=\"ne-text\">5</span></p></td></tr><tr style=\"height: 34px\"><td width=\"250\"><p id=\"u60db92e5\" class=\"ne-p\"><span class=\"ne-text\">110</span></p></td><td width=\"250\"><p id=\"ud0dcef02\" class=\"ne-p\"><span class=\"ne-text\">{1,2}</span></p></td><td width=\"250\"><p id=\"u5430e0d3\" class=\"ne-p\"><span class=\"ne-text\">6</span></p></td></tr><tr style=\"height: 34px\"><td width=\"250\"><p id=\"u2913d2dd\" class=\"ne-p\"><span class=\"ne-text\">111</span></p></td><td width=\"250\"><p id=\"u55ac6d4a\" class=\"ne-p\"><span class=\"ne-text\">{1,2,3}</span></p></td><td width=\"250\"><p id=\"u2f9b7393\" class=\"ne-p\"><span class=\"ne-text\">7</span></p></td></tr></tbody></table><p id=\"u6e1f0699\" class=\"ne-p\"><br></p><p id=\"u0b0c6aa8\" class=\"ne-p\"><span class=\"ne-text\">代码的具体实现上，可以通过 1 &lt;&lt; nums.length 获取子集的总数；可以利用性质 9 取出相应二进制位上的数值用以构建子集的具体结构。具体的代码实现如下：</span></p><pre data-language=\"javascript\" id=\"jFFlU\" class=\"ne-codeblock language-javascript\"><code>/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsets = function(nums) {\n  var res = [], len = nums.length\n  for (var i = 0; i &lt; (1 &lt;&lt; len); i++) {\n    var currSubset = []\n    for (var j = 0; j &lt;= len; j++) {\n      if (i &amp; (1 &lt;&lt; j)) currSubset.push(nums[j])\n    }\n    res.push(currSubset)\n  }\n  return res\n};</code></pre><p id=\"u24a2dc78\" class=\"ne-p\"><br></p><p id=\"ubd6dee89\" class=\"ne-p\"><span class=\"ne-text\">复杂度分析：</span></p><p id=\"uf439875a\" class=\"ne-p\"><span class=\"ne-text\">时间复杂度为 O(n2</span><sup><span class=\"ne-text\">n</span></sup><span class=\"ne-text\">))，子集的总数为 1 &lt;&lt; n 即 2</span><sup><span class=\"ne-text\">n</span></sup><span class=\"ne-text\"> 种，得 O(2</span><sup><span class=\"ne-text\">n</span></sup><span class=\"ne-text\">)，构造每个子集时需要遍历一次原数组，得 O(n)。</span></p><p id=\"uc7303653\" class=\"ne-p\"><span class=\"ne-text\">空间复杂度为 O(n)，只有构造子集时使用的临时数组需要额外空间的开销。</span></p><p id=\"ud1a8e40e\" class=\"ne-p\"><br></p><h4 id=\"yRvpU\"><span class=\"ne-text\">136 - 只出现一次的数字</span></h4><p id=\"u1264378c\" class=\"ne-p\"><a href=\"https://leetcode-cn.com/problems/single-number\" data-href=\"https://leetcode-cn.com/problems/single-number\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">https://leetcode-cn.com/problems/single-number</span></a></p><p id=\"ua3dc04af\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">给定一个</span><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">非空</span></strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</span></p><p id=\"u024462c9\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">说明：</span></strong></p><p id=\"udd07468d\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</span></p><p id=\"u6b203e87\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">示例 1:</span></strong></p><p id=\"u81b7dd9c\" class=\"ne-p\"><strong><span class=\"ne-text\">输入:</span></strong><span class=\"ne-text\"> [2,2,1]<br /></span><strong><span class=\"ne-text\">输出:</span></strong><span class=\"ne-text\"> 1</span></p><p id=\"u66ff2634\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38); font-size: 13px\">示例 2:</span></strong></p><p id=\"u5ce13a25\" class=\"ne-p\"><strong><span class=\"ne-text\">输入:</span></strong><span class=\"ne-text\"> [4,1,2,1,2]<br /></span><strong><span class=\"ne-text\">输出:</span></strong><span class=\"ne-text\"> 4</span></p><p id=\"uf9901564\" class=\"ne-p\"><br></p><p id=\"ue9a9d31e\" class=\"ne-p\"><span class=\"ne-text\">从位运算出发去思考，我们可以找到性质 1、2，两个相等的数异或之后为 0，一个数异或 0 等于它本身，那么将数组中所有元素相异或之后，出现 2 次的数字就会全部被约去，剩下只出现 1 次的数字，代码如下：</span></p><pre data-language=\"javascript\" id=\"kkUMB\" class=\"ne-codeblock language-javascript\"><code>/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singleNumber = function(nums) {\n  var res = 0\n  for (var i = 0; i &lt; nums.length; i++) {\n    res ^= nums[i]\n  }\n  return res\n};</code></pre><p id=\"u2bb64df9\" class=\"ne-p\"><br></p><p id=\"u5f8245d6\" class=\"ne-p\"><span class=\"ne-text\">复杂度分析：</span></p><p id=\"u6d29a597\" class=\"ne-p\"><span class=\"ne-text\">时间复杂度为 O(n)，因为只有一次遍历数组操作。</span></p><p id=\"u1e30703e\" class=\"ne-p\"><span class=\"ne-text\">空间复杂度为 O(1)，没有额外空间开销。</span></p><p id=\"u717329c3\" class=\"ne-p\"><br></p><h4 id=\"nKghx\"><span class=\"ne-text\">169 - 多数元素</span></h4><p id=\"uc677b429\" class=\"ne-p\"><a href=\"https://leetcode-cn.com/problems/majority-element\" data-href=\"https://leetcode-cn.com/problems/majority-element\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">https://leetcode-cn.com/problems/majority-element</span></a></p><p id=\"u2743adaf\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">给定一个大小为 </span><em><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">n </span></em><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">的数组，找到其中的多数元素。多数元素是指在数组中出现次数</span><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">大于 </span></strong><span class=\"ne-text\" style=\"color: rgba(var(--grey-7-rgb)\">⌊ n/2 ⌋</span><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\"> 的元素。</span></p><p id=\"u3ab9e360\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">你可以假设数组是非空的，并且给定的数组总是存在多数元素。</span></p><p id=\"u8cfde3f6\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">示例 1：</span></strong></p><p id=\"u7ec3241e\" class=\"ne-p\"><strong><span class=\"ne-text\">输入：</span></strong><span class=\"ne-text\">[3,2,3]<br /></span><strong><span class=\"ne-text\">输出：</span></strong><span class=\"ne-text\">3</span></p><p id=\"u9c3dc50a\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">示例 2：</span></strong></p><p id=\"u74663fbf\" class=\"ne-p\"><strong><span class=\"ne-text\">输入：</span></strong><span class=\"ne-text\">[2,2,1,1,1,2,2]<br /></span><strong><span class=\"ne-text\">输出：</span></strong><span class=\"ne-text\">2</span></p><p id=\"u16663d4d\" class=\"ne-p\"><br></p><p id=\"ufd382203\" class=\"ne-p\"><span class=\"ne-text\">题干要求的多数元素，出现次数大于 n/2，从位运算出发去思考可以推断，如果将每一个数字都用 32 位二进制序列列出，去统计每一个二进制位是 0 多还是 1 多，则由每一位的多数元素组成的二进制序列，就可以组成最终那个多数元素的数值。代码如下：</span></p><pre data-language=\"javascript\" id=\"hO1F8\" class=\"ne-codeblock language-javascript\"><code>/**\n * @param {number[]} nums\n * @return {number}\n */\nvar majorityElement = function(nums) {\n  var res = 0, len = nums.length\n  for (var i = 0; i &lt; 32; i++) {\n    var ones = 0, zero = 0\n    for (var j = 0; j &lt; len; j++) {\n      if (ones &gt; len / 2 || zero &gt; len / 2) {\n        break\n      }\n      if ((nums[j] &amp; (1 &lt;&lt; i)) === 0) {\n        zero++\n      } else {\n        ones++\n      }\n    }\n    if (ones &gt; zero) res |= 1 &lt;&lt; i\n  }\n  return res\n};</code></pre><p id=\"ub1590ef1\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u1f127fa4\" class=\"ne-p\"><span class=\"ne-text\">复杂度分析：</span></p><p id=\"ueee76fc8\" class=\"ne-p\"><span class=\"ne-text\">时间复杂度为 O(n)，一次枚举二进制序列上所有的位（32 位），一次遍历整个数组。</span></p><p id=\"uf4b47534\" class=\"ne-p\"><span class=\"ne-text\">空间复杂度为 O(1)，没有额外空间开销。</span></p><p id=\"u7d33da4f\" class=\"ne-p\"><br></p><h4 id=\"O1IrZ\"><span class=\"ne-text\">342 - 4 的幂</span></h4><p id=\"u2a08e918\" class=\"ne-p\"><a href=\"https://leetcode-cn.com/problems/power-of-four\" data-href=\"https://leetcode-cn.com/problems/power-of-four\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">https://leetcode-cn.com/problems/power-of-four</span></a></p><p id=\"u63def66d\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 </span><span class=\"ne-text\" style=\"color: rgba(var(--grey-7-rgb)\">true</span><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">；否则，返回 </span><span class=\"ne-text\" style=\"color: rgba(var(--grey-7-rgb)\">false</span><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">。</span></p><p id=\"uc37171e1\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">整数 </span><span class=\"ne-text\" style=\"color: rgba(var(--grey-7-rgb)\">n </span><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">是 4 的幂次方需满足：存在整数 </span><span class=\"ne-text\" style=\"color: rgba(var(--grey-7-rgb)\">x </span><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">使得 </span><span class=\"ne-text\" style=\"color: rgba(var(--grey-7-rgb)\">n == 4 ^ x。</span></p><p id=\"ud7d9f786\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">示例 1：</span></strong></p><p id=\"u6e56a1e7\" class=\"ne-p\"><strong><span class=\"ne-text\">输入：</span></strong><span class=\"ne-text\">n = 16<br /></span><strong><span class=\"ne-text\">输出：</span></strong><span class=\"ne-text\">true</span></p><p id=\"u286ab641\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">示例 2：</span></strong></p><p id=\"u5b902236\" class=\"ne-p\"><strong><span class=\"ne-text\">输入：</span></strong><span class=\"ne-text\">n = 5<br /></span><strong><span class=\"ne-text\">输出：</span></strong><span class=\"ne-text\">false</span></p><p id=\"u6025d7cf\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">示例 3：</span></strong></p><p id=\"u6b7f5943\" class=\"ne-p\"><strong><span class=\"ne-text\">输入：</span></strong><span class=\"ne-text\">n = 1<br /></span><strong><span class=\"ne-text\">输出：</span></strong><span class=\"ne-text\">true</span></p><p id=\"u4e178c7e\" class=\"ne-p\"><br></p><p id=\"uec8da32a\" class=\"ne-p\"><span class=\"ne-text\">将 32 个二进制位铺开来看，一个数为 4 的幂意味着有唯一的数字 1 在序列的奇数位置出现。</span></p><pre data-language=\"bash\" id=\"G2NmZ\" class=\"ne-codeblock language-bash\"><code>0000 0000 0000 0000 0000 0000 0000 0001 # 1\n0000 0000 0000 0000 0000 0000 0000 0100 # 4\n0000 0000 0000 0000 0000 0000 0001 0000 # 16\n0000 0000 0000 0000 0000 0000 0100 0000 # 64</code></pre><p id=\"u6b5eacff\" class=\"ne-p\"><span class=\"ne-text\">所以可以利用性质 11，根据消去最后一个 1 之后结果是否为 0，可以判断数字的二进制序列中是否存在唯一的 1；另外在循环中使用 &gt;&gt;&gt; 右移操作符直到数字为 0，可以统计出 1 的初始位置。因此代码如下：</span></p><pre data-language=\"javascript\" id=\"qrzEV\" class=\"ne-codeblock language-javascript\"><code>/**\n * @param {number} n\n * @return {boolean}\n */\nvar isPowerOfFour = function(n) {\n  // 是否唯一的 1\n  var onlyOne = (n &amp; (n - 1)) === 0\n  // 求 1 的位置\n  var pos = 0, temp = n\n  while (temp !== 0) {\n    temp &gt;&gt;&gt;= 1\n    pos++\n  }\n  // 若有唯一的 1，且 1 是奇数，则认为其是 4 的幂\n  return onlyOne &amp;&amp; ((pos &amp; 1) !== 0)\n};</code></pre><p id=\"u0cc071af\" class=\"ne-p\"><br></p><p id=\"ub9baac2e\" class=\"ne-p\"><span class=\"ne-text\">复杂度分析：</span></p><p id=\"u2ab14684\" class=\"ne-p\"><span class=\"ne-text\">时间复杂度为 O(1)，解中唯一的循环，是在二进制序列上移动，移动到数字本身为 0，即可求出唯一 1 原来的位置。</span></p><p id=\"ud107c150\" class=\"ne-p\"><span class=\"ne-text\">空间复杂度为 O(1)，没有额外空间开销。</span></p><p id=\"ufe04a20b\" class=\"ne-p\"><br></p><h4 id=\"J2fBK\"><span class=\"ne-text\">461 - 汉明距离</span></h4><p id=\"u073d15e0\" class=\"ne-p\"><a href=\"https://leetcode-cn.com/problems/hamming-distance\" data-href=\"https://leetcode-cn.com/problems/hamming-distance\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">https://leetcode-cn.com/problems/hamming-distance</span></a></p><p id=\"u5c3574ab\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">两个整数之间的</span><a href=\"https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB\" data-href=\"https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">汉明距离</span></a><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">指的是这两个数字对应二进制位不同的位置的数目。</span></p><p id=\"u157daa3e\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">给出两个整数 </span><span class=\"ne-text\" style=\"color: rgba(var(--grey-7-rgb)\">x </span><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">和 </span><span class=\"ne-text\" style=\"color: rgba(var(--grey-7-rgb)\">y</span><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">，计算它们之间的汉明距离。</span></p><p id=\"ub30fd67d\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">注意：</span></strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">0 ≤ </span><span class=\"ne-text\" style=\"color: rgba(var(--grey-7-rgb)\">x</span><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">, </span><span class=\"ne-text\" style=\"color: rgba(var(--grey-7-rgb)\">y </span><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">&lt; 231.</span></p><p id=\"ubce40f69\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">示例:</span></strong></p><p id=\"u76c95254\" class=\"ne-p\"><strong><span class=\"ne-text\">输入:</span></strong><span class=\"ne-text\"> x = 1, y = 4<br /></span><strong><span class=\"ne-text\">输出:</span></strong><span class=\"ne-text\"> 2</span></p><p id=\"uc0bb2333\" class=\"ne-p\"><span class=\"ne-text\">上面的箭头指出了对应二进制位不同的位置。</span></p><p id=\"ue9bc9909\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"ud30d1726\" class=\"ne-p\"><span class=\"ne-text\">首先列出示例中两个数的二进制序列：</span></p><pre data-language=\"bash\" id=\"UDOaA\" class=\"ne-codeblock language-bash\"><code>0000 0000 0000 0000 0000 0000 0000 0001\n0000 0000 0000 0000 0000 0000 0000 0100</code></pre><p id=\"ubcfe9919\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u74da1a36\" class=\"ne-p\"><span class=\"ne-text\">很明显，只要把两数相异或，二进制位不同的位在结果中即为 1，再使用性质 11 统计结果中 1 的个数，即可得解。因此代码如下：</span></p><pre data-language=\"javascript\" id=\"OfGKc\" class=\"ne-codeblock language-javascript\"><code>/**\n * @param {number} x\n * @param {number} y\n * @return {number}\n */\nvar hammingDistance = function(x, y) {\n  var xorRes = x ^ y, count = 0\n  while (xorRes !== 0) {\n    xorRes &amp;= (xorRes - 1)\n    count++\n  }\n  return count\n};</code></pre><p id=\"uf8386967\" class=\"ne-p\"><br></p><p id=\"udd7e35d3\" class=\"ne-p\"><span class=\"ne-text\">时间复杂度与空间复杂度均为 O(1)。</span></p><p id=\"uf28e563d\" class=\"ne-p\"><br></p><h4 id=\"qNFub\"><span class=\"ne-text\">1356 - 根据数字二进制下 1 的数目排序</span></h4><p id=\"u5581b511\" class=\"ne-p\"><a href=\"https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits\" data-href=\"https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits</span></a></p><p id=\"u11ca3c8d\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">给你一个整数数组 </span><span class=\"ne-text\" style=\"color: rgba(var(--grey-7-rgb)\">arr</span><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\"> 。请你将数组中的元素按照其二进制表示中数字 </span><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">1 </span></strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">的数目升序排序。</span></p><p id=\"u283d3ca8\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">如果存在多个数字二进制中 </span><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">1</span></strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\"> 的数目相同，则必须将它们按照数值大小升序排列。</span></p><p id=\"u2215dada\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">请你返回排序后的数组。</span></p><p id=\"ue101ce52\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">示例 1：</span></strong></p><p id=\"u06eb1016\" class=\"ne-p\"><strong><span class=\"ne-text\">输入：</span></strong><span class=\"ne-text\">arr = [0,1,2,3,4,5,6,7,8]<br /></span><strong><span class=\"ne-text\">输出：</span></strong><span class=\"ne-text\">[0,1,2,4,8,3,5,6,7]</span></p><p id=\"u064bcb16\" class=\"ne-p\"><strong><span class=\"ne-text\">解释：</span></strong><span class=\"ne-text\">[0] 是唯一一个有 0 个 1 的数。<br /></span><span class=\"ne-text\">[1,2,4,8] 都有 1 个 1。<br /></span><span class=\"ne-text\">[3,5,6] 有 2 个 1。</span></p><p id=\"u00f79758\" class=\"ne-p\"><span class=\"ne-text\">[7] 有 3 个 1 。<br /></span><span class=\"ne-text\">按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]</span></p><p id=\"u8a171db3\" class=\"ne-p\"><br></p><p id=\"ufc63bfd1\" class=\"ne-p\"><span class=\"ne-text\">最暴力的方法，直接调用语言自带的排序函数，对比函数中则使用性质 11 统计 value1 和 value2 二进制序列中 1 的个数，最终 1 的个数不同时按照 1 的个数升序，相同时按照数值大小升序。因此代码如下：</span></p><pre data-language=\"javascript\" id=\"vOOj7\" class=\"ne-codeblock language-javascript\"><code>/**\n * @param {number[]} arr\n * @return {number[]}\n */\nvar sortByBits = function(arr) {\n  return arr.sort((v1, v2) =&gt; {\n    var temp1 = v1, temp2 = v2, count1 = 0, count2 = 0\n    while (temp1 !== 0) {\n      temp1 &amp;= temp1 - 1\n      count1++\n    }\n    while (temp2 !== 0) {\n      temp2 &amp;= temp2 - 1\n      count2++\n    }\n    return count1 === count2 ? v1 - v2 : count1 - count2\n  })\n};</code></pre><p id=\"u73b6d5d4\" class=\"ne-p\"><br></p><p id=\"ub91e3a21\" class=\"ne-p\"><span class=\"ne-text\">复杂度分析：</span></p><p id=\"uc71a6dc0\" class=\"ne-p\"><span class=\"ne-text\">开销全部来自于系统自带的排序函数，JS 的 Array.prototype.sort 是使用快排实现的，因此复杂度与快排一致，时间复杂度为 O(nlog</span><sub><span class=\"ne-text\">n</span></sub><span class=\"ne-text\">)，空间复杂度为 O(n)。</span></p><p id=\"u7534c2ac\" class=\"ne-p\"><br></p><h4 id=\"H7d7d\"><span class=\"ne-text\">总结</span></h4><p id=\"u54ce3924\" class=\"ne-p\"><span class=\"ne-text\">在上面列出的题目中，我认为 </span><a href=\"https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#ooSe4\" data-href=\"https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#ooSe4\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">78 - 子集</span></a><span class=\"ne-text\"> 和 </span><a href=\"https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#gmonn\" data-href=\"https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#gmonn\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">169 - 多数元素</span></a><span class=\"ne-text\"> 是很有代表性的题目，这类问题的共通性在于，题干都可以拆分为多个是非问题的组合。</span><a href=\"https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#ooSe4\" data-href=\"https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#ooSe4\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">78 - 子集</span></a><span class=\"ne-text\"> 是被拆分为了数组中的每一个数是否存在的问题的集合；而 </span><a href=\"https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#gmonn\" data-href=\"https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#gmonn\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">169 - 多数元素</span></a><span class=\"ne-text\"> 则是被拆分为统计二进制序列中每一个位置上的多数值。因此在解题时可以从这个方向进行思考。</span></p><p id=\"u95a7a0b0\" class=\"ne-p\"><span class=\"ne-text\"></span></p><h3 id=\"aZgl9\"><span class=\"ne-text\">位掩码</span></h3><p id=\"u733984be\" class=\"ne-p\"><span class=\"ne-text\">虽然本篇是从算法角度切入，但是位运算在日常开发中还有一些实用的小技巧，比如知名 JS 函数库 Lodash 中使用到的位掩码技术。</span></p><p id=\"ua948ac3f\" class=\"ne-p\"><br></p><p id=\"ub135ef7b\" class=\"ne-p\"><span class=\"ne-text\">位掩码通常用于处理多个布尔变量的组合，在 Lodash 中，JS 对象拷贝相关函数的基础函数 baseClone 就使用了位掩码来控制不同的克隆方式。让我们直接来解读一下它的核心代码。</span></p><p id=\"u02546a62\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u39466a1e\" class=\"ne-p\"><span class=\"ne-text\">首先，我们需要几个预设的掩码，它们都是由一个仅有唯一 1 的二进制序列组成的（因此它们都是 2 的幂），每个二进制位代表一个开关，而后续的代码中，则可以通过某些二进制运算，来表示各种关系的不同组合：</span></p><pre data-language=\"javascript\" id=\"nYrA6\" class=\"ne-codeblock language-javascript\"><code>const CLONE_DEEP_FLAG = 1    // 0001：深拷贝\nconst CLONE_FLAT_FLAG = 2    // 0010：拷贝原型链标志位\nconst CLONE_SYMBOLS_FLAG = 4 // 0100：拷贝 Symbol 类型标志位</code></pre><p id=\"u43b41a08\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u8b21abba\" class=\"ne-p\"><span class=\"ne-text\">然后是 cloneDeep 的代码，它调用了 baseClone，并传入了掩码 </span><code class=\"ne-code\"><span class=\"ne-text\">CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG</span></code><span class=\"ne-text\">，这个表达式运算的结果是 5，也就是二进制的 0101。我们发现，通过 | 运算将两个掩码组合，就可以让两个标志位同时变成 1：</span></p><pre data-language=\"javascript\" id=\"z6yw1\" class=\"ne-codeblock language-javascript\"><code>function cloneDeep(value) {\n  // cloneDeep 需要深克隆和克隆 Symbol\n  // 1 | 4 -&gt; 0001 | 0100 -&gt; 0101\n  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG)\n}</code></pre><p id=\"u02276fd1\" class=\"ne-p\"><br></p><p id=\"u90195d37\" class=\"ne-p\"><span class=\"ne-text\">最后找到了 baseClone 的核心代码，这里将刚才传入的 </span><code class=\"ne-code\"><span class=\"ne-text\">CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG</span></code><span class=\"ne-text\"> 和三个掩码分别进行 &amp; 操作，突然发现这里正是用到了</span><a href=\"https://www.yuque.com/bufeidefeiyang/blog/rih5mgvkl294kred#XFuX7\" data-href=\"#XFuX7\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">常用性质</span></a><span class=\"ne-text\">中的性质 3！这时会发现，我们只要将传入的掩码 bitmask 与各个标志的掩码进行 &amp; 操作，则如果 bitmask 中相应的二进制位为 1，则结果就是该掩码的值；如果 bitmask 中相应的二进制位为 0，则结果就是 0。这样就可以为每个标志位生成其对应的布尔变量，用于后续的函数判断了：</span></p><pre data-language=\"javascript\" id=\"Ef269\" class=\"ne-codeblock language-javascript\"><code>// 刚才我们传入的值是 1 | 4 = 5\n// 因此 isDeep 的值即为 5 &amp; 1 = 1\n//   0101\n// &amp; 0001\n// ------\n//   0001\n// 可以发现，当传入掩码的二进制序列中存在相应标志位时\n// &amp; 操作就会直接返回当前标志位的掩码\n// 这样，如果返回的结果为 0，则意味着掩码中不存在相应标志位，结果为 0 == false\n// 如果返回的结果大于 0，则意味着掩码中存在相应标志位，结果为任意数字，转换为布尔值为 true\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  const isDeep = bitmask &amp; CLONE_DEEP_FLAG\n  const isFlat = bitmask &amp; CLONE_FLAT_FLAG\n  const isFull = bitmask &amp; CLONE_SYMBOLS_FLAG\n  ...\n}</code></pre><p id=\"0eb510c38385bc470bfff82ac79ecd62\" class=\"ne-p\"><br></p><h3 id=\"RTGHj\"><span class=\"ne-text\">References</span></h3><ul class=\"ne-ul\"><li id=\"uc950f443\" data-lake-index-type=\"0\"><a href=\"https://www.zhihu.com/question/38206659/answer/392527806\" data-href=\"https://www.zhihu.com/question/38206659/answer/392527806\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">位运算有什么奇技淫巧？ - 伍亦勤的回答 - 知乎</span></a></li><li id=\"ubd2978bc\" data-lake-index-type=\"0\"><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6\" data-href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">位运算符 - MDN</span></a></li><li id=\"u425487d1\" data-lake-index-type=\"0\"><a href=\"https://github.com/yygmind/blog/issues/31\" data-href=\"https://github.com/yygmind/blog/issues/31\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">【进阶4-4期】Lodash是如何实现深拷贝的 - 木易杨</span></a></li></ul></div>","body":"\n# 位运算的算法应用\n\n### 基本介绍\n作为算法题的一个大类，位运算相关的题目常常出现在各大公司的面试/笔试题中，下面先说说位运算的基本原理。\n\n位运算使得计算机可以直接对每个比特位进行计算，效率会非常的高。\n\n在 JS 中，位运算会将操作数当作 32 位的二进制串进行计算，如果二进制串超过 32 位，则只保留最后的 32 位进行计算，如：\n```bash\n11100110111110100000000000000110000000000001 # 输入的二进制串\n            10100000000000000110000000000001 # 实际使用的二进制串\n```\n\n在 JS 中，位运算有 7 种运算符：\n\n1. 按位与（a & b）：在 a, b 的位表示中，每一个对应的位都为 1 则返回 1，否则返回 0\n```bash\n# 15 & 9 -> 9\n  0000 0000 0000 0000 0000 0000 0000 1111\n& 0000 0000 0000 0000 0000 0000 0000 1001\n  ---------------------------------------\n  0000 0000 0000 0000 0000 0000 0000 1001\n```\n\n2. 按位或（a | b）：在 a, b 的位表示中，每一个对应的位，只要有一个为 1 则返回 1，否则返回 0\n```bash\n# 15 | 9 -> 15\n  0000 0000 0000 0000 0000 0000 0000 1111\n| 0000 0000 0000 0000 0000 0000 0000 1001\n  ---------------------------------------\n  0000 0000 0000 0000 0000 0000 0000 1111\n```\n\n3. 按位异或（a ^ b）：在 a, b 的位表示中，每一个对应的位，两个不相同则返回 1，相同则返回 0\n```bash\n# 15 ^ 9 -> 6\n  0000 0000 0000 0000 0000 0000 0000 1111\n| 0000 0000 0000 0000 0000 0000 0000 1001\n  ---------------------------------------\n  0000 0000 0000 0000 0000 0000 0000 0110\n```\n\n4. 按位非（~a）：反转被操作数的位，即将每一位的 0 转为 1，1 转为 0\n```bash\n# ~15 -> -16\n~ 0000 0000 0000 0000 0000 0000 0000 1111\n  ---------------------------------------\n  1111 1111 1111 1111 1111 1111 1111 0000\n```\n\n5. 左移（a << b）：将 a 的二进制串向左移动 b 位，右边移入 0\n```bash\n# 9 << 2 -> 36\n<<  0000 0000 0000 0000 0000 0000 0000 1001\n    ---------------------------------------\n    0000 0000 0000 0000 0000 0000 0010 0100\n```\n\n6. 有符号右移（a >> b）：把 a 的二进制表示向右移动 b 位，向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。这种右移由于保留最左侧的二进制位，因此可以保留数字原本的正负符号\n```bash\n# 9 >> 2 -> 2\n>>  0000 0000 0000 0000 0000 0000 0000 1001\n    ---------------------------------------\n    0000 0000 0000 0000 0000 0000 0010 0010\n# -9 >> 2 -> -3\n>>  1111 1111 1111 1111 1111 1111 1111 0111\n    ---------------------------------------\n    1111 1111 1111 1111 1111 1111 1111 1101\n```\n\n7. 无符号右移（a >>> b）：把 a 的二进制表示向右移动 b 位，向右被移出的位被丢弃，左边空出的位全部填充为 0。这种右移由于左侧直接补 0，因此生成的数字必然是非负数\n```bash\n# 19 >>> 2 -> 4\n>>>  0000 0000 0000 0000 0000 0000 0001 0011\n     ---------------------------------------\n     0000 0000 0000 0000 0000 0000 0010 0010\n# -19 >>> 2 -> 1073741819\n>>>  1111 1111 1111 1111 1111 1111 1110 1101\n     ---------------------------------------\n     0011 1111 1111 1111 1111 1111 1111 0011\n```\n\n\n### 常用性质\n在使用位运算技巧解的算法题中，有以下这些常用的性质：\n\n1. a 与自身之间的操作\n```bash\na & a = a\na | a = a\na ^ a = 0\n```\n\n2. a 与 0 之间的操作\n```bash\na & 0 = 0\na | 0 = a\na ^ 0 = a\n```\n\n3. 按位与、按位或的还原计算\n```bash\na | ( a & b ) = a\na & ( a | b ) = a\n```\n\n4. 通过异或完成变量值交换\n```bash\na ^= b\nb ^= a\na ^= b\n```\n\n5. 判断奇偶（通过 & 1 取出最后一个二进制位以达到模 2 的效果）\n```bash\n# 位运算效率更高\na & 1 === a % 2\n```\n\n6. 比较两值是否相等（a ^ a === 0）\n```bash\na ^ b === 0\n```\n\n7. 将第 i + 1 个二进制位设为 1\n```bash\na |= 1 << i\n```\n\n8. 将第 i + 1 个二进制位设为 0\n```bash\na &= ~(1 << i)\n```\n\n9. 取出第 i + 1 个二进制位上的数值\n```bash\na & (1 << i)\n```\n\n10. 在 a 第 i + 1 个二进制位，插入 b 对应位置的二进制位\n```bash\na |= 1 << i\na & (b & 1 << i)\n```\n\n11. 删除二进制序列中最后一个值为 1 的位置\n```bash\na &= (a - 1)\n```\n\n12. 计算 a 的相反数\n```bash\n-a === ~a + 1\n```\n\n13. 保留 a 在二进制位中最后一个 1\n```bash\na &= (-a)\n```\n\n14. 生成二进制位全为 1 的数\n```bash\n~0\n```\n\n15. 保留 a 二进制序列中最后的 i - 1 位，其余补 0\n```bash\na & ((1 << i) - 1)\n```\n\n16. 将 a 二进制序列中最后 i - 1 位全部置为 0\n```bash\na & ~((1 << i) - 1)\n```\n\n17. 判断 a 的二进制序列最高位是否为 1\n```bash\na < 0 # 最高位为 1 必然是负数\n```\n\n18. 在二进制序列中，仅保留最高位的 1，其他设为 0，输出该数\n```bash\na = a | (a >> 1)\na = a | (a >> 2)\na = a | (a >> 4)\na = a | (a >> 8)\na = a | (a >> 16)\nreturn (a + 1) >> 1\n```\n\n下面，我们通过一些简单-中等的题目来体验一下位运算解题的巧妙。\n\n\n### 题目\n\n#### 78 - 子集\n[https://leetcode-cn.com/problems/subsets](https://leetcode-cn.com/problems/subsets)\n给你一个整数数组 nums，数组中的元素**互不相同**。返回该数组所有可能的子集（幂集）。\n解集**不能**包含重复的子集。你可以按**任意顺序**返回解集。\n**示例 1：**\n**输入：**nums = [1,2,3]\n**输出：**[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\n从位运算出发去思考，如果用 0 和 1 标记一个数是否存在于子集中，这样列下来，例子中的输入 [1,2,3] 就会产生下表所示的子集与 0/1 序列的关系，因此我们可以直接遍历这个 0/1 序列，去构建每个子集的数据。\n\n| 0/1序列 | 子集 | 0/1序列对应的二进制数 |\n| --- | --- | --- |\n| 000 | {} | 0 |\n| 001 | {3} | 1 |\n| 010 | {2} | 2 |\n| 011 | {2,3} | 3 |\n| 100 | {1} | 4 |\n| 101 | {1,3} | 5 |\n| 110 | {1,2} | 6 |\n| 111 | {1,2,3} | 7 |\n\n\n代码的具体实现上，可以通过 1 << nums.length 获取子集的总数；可以利用性质 9 取出相应二进制位上的数值用以构建子集的具体结构。具体的代码实现如下：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsets = function(nums) {\n  var res = [], len = nums.length\n  for (var i = 0; i < (1 << len); i++) {\n    var currSubset = []\n    for (var j = 0; j <= len; j++) {\n      if (i & (1 << j)) currSubset.push(nums[j])\n    }\n    res.push(currSubset)\n  }\n  return res\n};\n```\n\n复杂度分析：\n时间复杂度为 O(n2n))，子集的总数为 1 << n 即 2n 种，得 O(2n)，构造每个子集时需要遍历一次原数组，得 O(n)。\n空间复杂度为 O(n)，只有构造子集时使用的临时数组需要额外空间的开销。\n\n\n#### 136 - 只出现一次的数字\n[https://leetcode-cn.com/problems/single-number](https://leetcode-cn.com/problems/single-number)\n给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n**说明：**\n你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n**示例 1:**\n**输入:** [2,2,1]\n**输出:** 1\n**示例 2:**\n**输入:** [4,1,2,1,2]\n**输出:** 4\n\n从位运算出发去思考，我们可以找到性质 1、2，两个相等的数异或之后为 0，一个数异或 0 等于它本身，那么将数组中所有元素相异或之后，出现 2 次的数字就会全部被约去，剩下只出现 1 次的数字，代码如下：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singleNumber = function(nums) {\n  var res = 0\n  for (var i = 0; i < nums.length; i++) {\n    res ^= nums[i]\n  }\n  return res\n};\n```\n\n复杂度分析：\n时间复杂度为 O(n)，因为只有一次遍历数组操作。\n空间复杂度为 O(1)，没有额外空间开销。\n\n\n#### 169 - 多数元素\n[https://leetcode-cn.com/problems/majority-element](https://leetcode-cn.com/problems/majority-element)\n给定一个大小为 _n _的数组，找到其中的多数元素。多数元素是指在数组中出现次数**大于 **⌊ n/2 ⌋ 的元素。\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n**示例 1：**\n**输入：**[3,2,3]\n**输出：**3\n**示例 2：**\n**输入：**[2,2,1,1,1,2,2]\n**输出：**2\n\n题干要求的多数元素，出现次数大于 n/2，从位运算出发去思考可以推断，如果将每一个数字都用 32 位二进制序列列出，去统计每一个二进制位是 0 多还是 1 多，则由每一位的多数元素组成的二进制序列，就可以组成最终那个多数元素的数值。代码如下：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar majorityElement = function(nums) {\n  var res = 0, len = nums.length\n  for (var i = 0; i < 32; i++) {\n    var ones = 0, zero = 0\n    for (var j = 0; j < len; j++) {\n      if (ones > len / 2 || zero > len / 2) {\n        break\n      }\n      if ((nums[j] & (1 << i)) === 0) {\n        zero++\n      } else {\n        ones++\n      }\n    }\n    if (ones > zero) res |= 1 << i\n  }\n  return res\n};\n```\n\n复杂度分析：\n时间复杂度为 O(n)，一次枚举二进制序列上所有的位（32 位），一次遍历整个数组。\n空间复杂度为 O(1)，没有额外空间开销。\n\n\n#### 342 - 4 的幂\n[https://leetcode-cn.com/problems/power-of-four](https://leetcode-cn.com/problems/power-of-four)\n给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true；否则，返回 false。\n整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4 ^ x。\n**示例 1：**\n**输入：**n = 16\n**输出：**true\n**示例 2：**\n**输入：**n = 5\n**输出：**false\n**示例 3：**\n**输入：**n = 1\n**输出：**true\n\n将 32 个二进制位铺开来看，一个数为 4 的幂意味着有唯一的数字 1 在序列的奇数位置出现。\n```bash\n0000 0000 0000 0000 0000 0000 0000 0001 # 1\n0000 0000 0000 0000 0000 0000 0000 0100 # 4\n0000 0000 0000 0000 0000 0000 0001 0000 # 16\n0000 0000 0000 0000 0000 0000 0100 0000 # 64\n```\n所以可以利用性质 11，根据消去最后一个 1 之后结果是否为 0，可以判断数字的二进制序列中是否存在唯一的 1；另外在循环中使用 >>> 右移操作符直到数字为 0，可以统计出 1 的初始位置。因此代码如下：\n```javascript\n/**\n * @param {number} n\n * @return {boolean}\n */\nvar isPowerOfFour = function(n) {\n  // 是否唯一的 1\n  var onlyOne = (n & (n - 1)) === 0\n  // 求 1 的位置\n  var pos = 0, temp = n\n  while (temp !== 0) {\n    temp >>>= 1\n    pos++\n  }\n  // 若有唯一的 1，且 1 是奇数，则认为其是 4 的幂\n  return onlyOne && ((pos & 1) !== 0)\n};\n```\n\n复杂度分析：\n时间复杂度为 O(1)，解中唯一的循环，是在二进制序列上移动，移动到数字本身为 0，即可求出唯一 1 原来的位置。\n空间复杂度为 O(1)，没有额外空间开销。\n\n\n#### 461 - 汉明距离\n[https://leetcode-cn.com/problems/hamming-distance](https://leetcode-cn.com/problems/hamming-distance)\n两个整数之间的[汉明距离](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB)指的是这两个数字对应二进制位不同的位置的数目。\n给出两个整数 x 和 y，计算它们之间的汉明距离。\n**注意：**0 ≤ x, y < 231.\n**示例:**\n**输入:** x = 1, y = 4\n**输出:** 2\n上面的箭头指出了对应二进制位不同的位置。\n\n首先列出示例中两个数的二进制序列：\n```bash\n0000 0000 0000 0000 0000 0000 0000 0001\n0000 0000 0000 0000 0000 0000 0000 0100\n```\n\n很明显，只要把两数相异或，二进制位不同的位在结果中即为 1，再使用性质 11 统计结果中 1 的个数，即可得解。因此代码如下：\n```javascript\n/**\n * @param {number} x\n * @param {number} y\n * @return {number}\n */\nvar hammingDistance = function(x, y) {\n  var xorRes = x ^ y, count = 0\n  while (xorRes !== 0) {\n    xorRes &= (xorRes - 1)\n    count++\n  }\n  return count\n};\n```\n\n时间复杂度与空间复杂度均为 O(1)。\n\n\n#### 1356 - 根据数字二进制下 1 的数目排序\n[https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits](https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits)\n给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 **1 **的数目升序排序。\n如果存在多个数字二进制中 **1** 的数目相同，则必须将它们按照数值大小升序排列。\n请你返回排序后的数组。\n**示例 1：**\n**输入：**arr = [0,1,2,3,4,5,6,7,8]\n**输出：**[0,1,2,4,8,3,5,6,7]\n**解释：**[0] 是唯一一个有 0 个 1 的数。\n[1,2,4,8] 都有 1 个 1。\n[3,5,6] 有 2 个 1。\n[7] 有 3 个 1 。\n按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]\n\n最暴力的方法，直接调用语言自带的排序函数，对比函数中则使用性质 11 统计 value1 和 value2 二进制序列中 1 的个数，最终 1 的个数不同时按照 1 的个数升序，相同时按照数值大小升序。因此代码如下：\n```javascript\n/**\n * @param {number[]} arr\n * @return {number[]}\n */\nvar sortByBits = function(arr) {\n  return arr.sort((v1, v2) => {\n    var temp1 = v1, temp2 = v2, count1 = 0, count2 = 0\n    while (temp1 !== 0) {\n      temp1 &= temp1 - 1\n      count1++\n    }\n    while (temp2 !== 0) {\n      temp2 &= temp2 - 1\n      count2++\n    }\n    return count1 === count2 ? v1 - v2 : count1 - count2\n  })\n};\n```\n\n复杂度分析：\n开销全部来自于系统自带的排序函数，JS 的 Array.prototype.sort 是使用快排实现的，因此复杂度与快排一致，时间复杂度为 O(nlogn)，空间复杂度为 O(n)。\n\n\n#### 总结\n在上面列出的题目中，我认为 [78 - 子集](https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#ooSe4) 和 [169 - 多数元素](https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#gmonn) 是很有代表性的题目，这类问题的共通性在于，题干都可以拆分为多个是非问题的组合。[78 - 子集](https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#ooSe4) 是被拆分为了数组中的每一个数是否存在的问题的集合；而 [169 - 多数元素](https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#gmonn) 则是被拆分为统计二进制序列中每一个位置上的多数值。因此在解题时可以从这个方向进行思考。\n\n\n### 位掩码\n虽然本篇是从算法角度切入，但是位运算在日常开发中还有一些实用的小技巧，比如知名 JS 函数库 Lodash 中使用到的位掩码技术。\n\n位掩码通常用于处理多个布尔变量的组合，在 Lodash 中，JS 对象拷贝相关函数的基础函数 baseClone 就使用了位掩码来控制不同的克隆方式。让我们直接来解读一下它的核心代码。\n\n首先，我们需要几个预设的掩码，它们都是由一个仅有唯一 1 的二进制序列组成的（因此它们都是 2 的幂），每个二进制位代表一个开关，而后续的代码中，则可以通过某些二进制运算，来表示各种关系的不同组合：\n```javascript\nconst CLONE_DEEP_FLAG = 1    // 0001：深拷贝\nconst CLONE_FLAT_FLAG = 2    // 0010：拷贝原型链标志位\nconst CLONE_SYMBOLS_FLAG = 4 // 0100：拷贝 Symbol 类型标志位\n```\n\n然后是 cloneDeep 的代码，它调用了 baseClone，并传入了掩码 `CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG`，这个表达式运算的结果是 5，也就是二进制的 0101。我们发现，通过 | 运算将两个掩码组合，就可以让两个标志位同时变成 1：\n```javascript\nfunction cloneDeep(value) {\n  // cloneDeep 需要深克隆和克隆 Symbol\n  // 1 | 4 -> 0001 | 0100 -> 0101\n  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG)\n}\n```\n\n最后找到了 baseClone 的核心代码，这里将刚才传入的 `CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG` 和三个掩码分别进行 & 操作，突然发现这里正是用到了[常用性质](#XFuX7)中的性质 3！这时会发现，我们只要将传入的掩码 bitmask 与各个标志的掩码进行 & 操作，则如果 bitmask 中相应的二进制位为 1，则结果就是该掩码的值；如果 bitmask 中相应的二进制位为 0，则结果就是 0。这样就可以为每个标志位生成其对应的布尔变量，用于后续的函数判断了：\n```javascript\n// 刚才我们传入的值是 1 | 4 = 5\n// 因此 isDeep 的值即为 5 & 1 = 1\n//   0101\n// & 0001\n// ------\n//   0001\n// 可以发现，当传入掩码的二进制序列中存在相应标志位时\n// & 操作就会直接返回当前标志位的掩码\n// 这样，如果返回的结果为 0，则意味着掩码中不存在相应标志位，结果为 0 == false\n// 如果返回的结果大于 0，则意味着掩码中存在相应标志位，结果为任意数字，转换为布尔值为 true\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  const isDeep = bitmask & CLONE_DEEP_FLAG\n  const isFlat = bitmask & CLONE_FLAT_FLAG\n  const isFull = bitmask & CLONE_SYMBOLS_FLAG\n  ...\n}\n```\n\n\n### References\n\n- [位运算有什么奇技淫巧？ - 伍亦勤的回答 - 知乎](https://www.zhihu.com/question/38206659/answer/392527806)\n- [位运算符 - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6)\n- [【进阶4-4期】Lodash是如何实现深拷贝的 - 木易杨](https://github.com/yygmind/blog/issues/31)\n","body_html":"<!doctype html><html><head><link rel=\"stylesheet\" href=\"http://editor.yuque.com/ne-editor/lake-content-v1.css\">\n    </head><body><div class=\"lake-content\" typography=\"traditional\"><h1 id=\"sVa17\"><span class=\"ne-text\">位运算的算法应用</span></h1><h3 id=\"Iucu7\"><span class=\"ne-text\">基本介绍</span></h3><p id=\"u1c44377e\" class=\"ne-p\"><span class=\"ne-text\">作为算法题的一个大类，位运算相关的题目常常出现在各大公司的面试/笔试题中，下面先说说位运算的基本原理。</span></p><p id=\"ud4f433d3\" class=\"ne-p\"><br></p><p id=\"u8d638f3f\" class=\"ne-p\"><span class=\"ne-text\">位运算使得计算机可以直接对每个比特位进行计算，效率会非常的高。</span></p><p id=\"u8eaa65a5\" class=\"ne-p\"><br></p><p id=\"ub7943adc\" class=\"ne-p\"><span class=\"ne-text\">在 JS 中，位运算会将操作数当作 32 位的二进制串进行计算，如果二进制串超过 32 位，则只保留最后的 32 位进行计算，如：</span></p><pre data-language=\"bash\" id=\"SE8ru\" class=\"ne-codeblock language-bash\"><code>11100110111110100000000000000110000000000001 # 输入的二进制串\n            10100000000000000110000000000001 # 实际使用的二进制串</code></pre><p id=\"ud7b727ee\" class=\"ne-p\"><br></p><p id=\"u1861599c\" class=\"ne-p\"><span class=\"ne-text\">在 JS 中，位运算有 7 种运算符：</span></p><p id=\"uaa709a72\" class=\"ne-p\"><br></p><ol class=\"ne-ol\"><li id=\"u4f0e2f25\" data-lake-index-type=\"0\"><span class=\"ne-text\">按位与（a &#x26; b）：在 a, b 的位表示中，每一个对应的位都为 1 则返回 1，否则返回 0</span></li></ol><pre data-language=\"bash\" id=\"Qkrsx\" class=\"ne-codeblock language-bash\"><code># 15 &#x26; 9 -> 9\n  0000 0000 0000 0000 0000 0000 0000 1111\n&#x26; 0000 0000 0000 0000 0000 0000 0000 1001\n  ---------------------------------------\n  0000 0000 0000 0000 0000 0000 0000 1001</code></pre><p id=\"u16b492fd\" class=\"ne-p\"><br></p><ol start=\"2\" class=\"ne-ol\"><li id=\"u823ca447\" data-lake-index-type=\"0\"><span class=\"ne-text\">按位或（a | b）：在 a, b 的位表示中，每一个对应的位，只要有一个为 1 则返回 1，否则返回 0</span></li></ol><pre data-language=\"bash\" id=\"JTgrM\" class=\"ne-codeblock language-bash\"><code># 15 | 9 -> 15\n  0000 0000 0000 0000 0000 0000 0000 1111\n| 0000 0000 0000 0000 0000 0000 0000 1001\n  ---------------------------------------\n  0000 0000 0000 0000 0000 0000 0000 1111</code></pre><p id=\"ue15e2835\" class=\"ne-p\"><br></p><ol start=\"3\" class=\"ne-ol\"><li id=\"ue71095b2\" data-lake-index-type=\"0\"><span class=\"ne-text\">按位异或（a ^ b）：在 a, b 的位表示中，每一个对应的位，两个不相同则返回 1，相同则返回 0</span></li></ol><pre data-language=\"bash\" id=\"AenYs\" class=\"ne-codeblock language-bash\"><code># 15 ^ 9 -> 6\n  0000 0000 0000 0000 0000 0000 0000 1111\n| 0000 0000 0000 0000 0000 0000 0000 1001\n  ---------------------------------------\n  0000 0000 0000 0000 0000 0000 0000 0110</code></pre><p id=\"u91c29dcb\" class=\"ne-p\"><br></p><ol start=\"4\" class=\"ne-ol\"><li id=\"u684452ea\" data-lake-index-type=\"0\"><span class=\"ne-text\">按位非（~a）：反转被操作数的位，即将每一位的 0 转为 1，1 转为 0</span></li></ol><pre data-language=\"bash\" id=\"bSQvX\" class=\"ne-codeblock language-bash\"><code># ~15 -> -16\n~ 0000 0000 0000 0000 0000 0000 0000 1111\n  ---------------------------------------\n  1111 1111 1111 1111 1111 1111 1111 0000</code></pre><p id=\"ufeab8f23\" class=\"ne-p\"><br></p><ol start=\"5\" class=\"ne-ol\"><li id=\"u0e14f280\" data-lake-index-type=\"0\"><span class=\"ne-text\">左移（a &#x3C;&#x3C; b）：将 a 的二进制串向左移动 b 位，右边移入 0</span></li></ol><pre data-language=\"bash\" id=\"wuNyp\" class=\"ne-codeblock language-bash\"><code># 9 &#x3C;&#x3C; 2 -> 36\n&#x3C;&#x3C;  0000 0000 0000 0000 0000 0000 0000 1001\n    ---------------------------------------\n    0000 0000 0000 0000 0000 0000 0010 0100</code></pre><p id=\"u0545f9a9\" class=\"ne-p\"><br></p><p id=\"u0c06431d\" class=\"ne-p\"><span class=\"ne-text\">6. 有符号右移（a >> b）：把 a 的二进制表示向右移动 b 位，向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。这种右移由于保留最左侧的二进制位，因此可以保留数字原本的正负符号</span></p><pre data-language=\"bash\" id=\"zD0S8\" class=\"ne-codeblock language-bash\"><code># 9 >> 2 -> 2\n>>  0000 0000 0000 0000 0000 0000 0000 1001\n    ---------------------------------------\n    0000 0000 0000 0000 0000 0000 0010 0010\n# -9 >> 2 -> -3\n>>  1111 1111 1111 1111 1111 1111 1111 0111\n    ---------------------------------------\n    1111 1111 1111 1111 1111 1111 1111 1101</code></pre><p id=\"u79fd751e\" class=\"ne-p\"><br></p><p id=\"ud31e3f62\" class=\"ne-p\"><span class=\"ne-text\">7. 无符号右移（a >>> b）：把 a 的二进制表示向右移动 b 位，向右被移出的位被丢弃，左边空出的位全部填充为 0。这种右移由于左侧直接补 0，因此生成的数字必然是非负数</span></p><pre data-language=\"bash\" id=\"SlQN1\" class=\"ne-codeblock language-bash\"><code># 19 >>> 2 -> 4\n>>>  0000 0000 0000 0000 0000 0000 0001 0011\n     ---------------------------------------\n     0000 0000 0000 0000 0000 0000 0010 0010\n# -19 >>> 2 -> 1073741819\n>>>  1111 1111 1111 1111 1111 1111 1110 1101\n     ---------------------------------------\n     0011 1111 1111 1111 1111 1111 1111 0011</code></pre><p id=\"ud0bf4c39\" class=\"ne-p\"><br></p><h3 id=\"xxuVW\"><span class=\"ne-text\">常用性质</span></h3><p id=\"u4d3a64fa\" class=\"ne-p\"><span class=\"ne-text\">在使用位运算技巧解的算法题中，有以下这些常用的性质：</span></p><p id=\"ubb626212\" class=\"ne-p\"><br></p><ol class=\"ne-ol\"><li id=\"u3fb5476e\" data-lake-index-type=\"0\"><span class=\"ne-text\">a 与自身之间的操作</span></li></ol><pre data-language=\"bash\" id=\"arLYF\" class=\"ne-codeblock language-bash\"><code>a &#x26; a = a\na | a = a\na ^ a = 0</code></pre><p id=\"uff01915b\" class=\"ne-p\"><br></p><ol start=\"2\" class=\"ne-ol\"><li id=\"u411dd390\" data-lake-index-type=\"0\"><span class=\"ne-text\">a 与 0 之间的操作</span></li></ol><pre data-language=\"bash\" id=\"o3kc0\" class=\"ne-codeblock language-bash\"><code>a &#x26; 0 = 0\na | 0 = a\na ^ 0 = a</code></pre><p id=\"u720b807a\" class=\"ne-p\"><br></p><ol start=\"3\" class=\"ne-ol\"><li id=\"ua0dd6598\" data-lake-index-type=\"0\"><span class=\"ne-text\">按位与、按位或的还原计算</span></li></ol><pre data-language=\"bash\" id=\"fuArK\" class=\"ne-codeblock language-bash\"><code>a | ( a &#x26; b ) = a\na &#x26; ( a | b ) = a</code></pre><p id=\"u251dc115\" class=\"ne-p\"><br></p><ol start=\"4\" class=\"ne-ol\"><li id=\"ubda7c069\" data-lake-index-type=\"0\"><span class=\"ne-text\">通过异或完成变量值交换</span></li></ol><pre data-language=\"bash\" id=\"Xn9kL\" class=\"ne-codeblock language-bash\"><code>a ^= b\nb ^= a\na ^= b</code></pre><p id=\"ub4ecd415\" class=\"ne-p\"><br></p><ol start=\"5\" class=\"ne-ol\"><li id=\"u7b658c74\" data-lake-index-type=\"0\"><span class=\"ne-text\">判断奇偶（通过 &#x26; 1 取出最后一个二进制位以达到模 2 的效果）</span></li></ol><pre data-language=\"bash\" id=\"e6tTC\" class=\"ne-codeblock language-bash\"><code># 位运算效率更高\na &#x26; 1 === a % 2</code></pre><p id=\"udc81b3b2\" class=\"ne-p\"><br></p><ol start=\"6\" class=\"ne-ol\"><li id=\"u47924ae6\" data-lake-index-type=\"0\"><span class=\"ne-text\">比较两值是否相等（a ^ a === 0）</span></li></ol><pre data-language=\"bash\" id=\"V0M5G\" class=\"ne-codeblock language-bash\"><code>a ^ b === 0</code></pre><p id=\"udd5fa9a3\" class=\"ne-p\"><br></p><ol start=\"7\" class=\"ne-ol\"><li id=\"u91fd07ef\" data-lake-index-type=\"0\"><span class=\"ne-text\">将第 i + 1 个二进制位设为 1</span></li></ol><pre data-language=\"bash\" id=\"ZdlbV\" class=\"ne-codeblock language-bash\"><code>a |= 1 &#x3C;&#x3C; i</code></pre><ol start=\"8\" class=\"ne-ol\"><li id=\"u1cf8c836\" data-lake-index-type=\"0\"><span class=\"ne-text\">将第 i + 1 个二进制位设为 0</span></li></ol><pre data-language=\"bash\" id=\"H6SAG\" class=\"ne-codeblock language-bash\"><code>a &#x26;= ~(1 &#x3C;&#x3C; i)</code></pre><p id=\"u5b0c7c4a\" class=\"ne-p\"><br></p><ol start=\"9\" class=\"ne-ol\"><li id=\"u44880742\" data-lake-index-type=\"0\"><span class=\"ne-text\">取出第 i + 1 个二进制位上的数值</span></li></ol><pre data-language=\"bash\" id=\"mX0SU\" class=\"ne-codeblock language-bash\"><code>a &#x26; (1 &#x3C;&#x3C; i)</code></pre><ol start=\"10\" class=\"ne-ol\"><li id=\"ua2c5ab02\" data-lake-index-type=\"0\"><span class=\"ne-text\">在 a 第 i + 1 个二进制位，插入 b 对应位置的二进制位</span></li></ol><pre data-language=\"bash\" id=\"TvVrJ\" class=\"ne-codeblock language-bash\"><code>a |= 1 &#x3C;&#x3C; i\na &#x26; (b &#x26; 1 &#x3C;&#x3C; i)</code></pre><p id=\"u40cc7c19\" class=\"ne-p\"><br></p><ol start=\"11\" class=\"ne-ol\"><li id=\"ub9c4a2f3\" data-lake-index-type=\"0\"><span class=\"ne-text\">删除二进制序列中最后一个值为 1 的位置</span></li></ol><pre data-language=\"bash\" id=\"X55hp\" class=\"ne-codeblock language-bash\"><code>a &#x26;= (a - 1)</code></pre><p id=\"u9c58d752\" class=\"ne-p\"><br></p><ol start=\"12\" class=\"ne-ol\"><li id=\"ue8e8b963\" data-lake-index-type=\"0\"><span class=\"ne-text\">计算 a 的相反数</span></li></ol><pre data-language=\"bash\" id=\"YOdPx\" class=\"ne-codeblock language-bash\"><code>-a === ~a + 1</code></pre><p id=\"u4df312f9\" class=\"ne-p\"><br></p><ol start=\"13\" class=\"ne-ol\"><li id=\"ua40b55d2\" data-lake-index-type=\"0\"><span class=\"ne-text\">保留 a 在二进制位中最后一个 1</span></li></ol><pre data-language=\"bash\" id=\"oiVlA\" class=\"ne-codeblock language-bash\"><code>a &#x26;= (-a)</code></pre><p id=\"u138fb043\" class=\"ne-p\"><br></p><ol start=\"14\" class=\"ne-ol\"><li id=\"u0d616c55\" data-lake-index-type=\"0\"><span class=\"ne-text\">生成二进制位全为 1 的数</span></li></ol><pre data-language=\"bash\" id=\"UhCrh\" class=\"ne-codeblock language-bash\"><code>~0</code></pre><p id=\"u5164dee9\" class=\"ne-p\"><br></p><ol start=\"15\" class=\"ne-ol\"><li id=\"u86ea175e\" data-lake-index-type=\"0\"><span class=\"ne-text\">保留 a 二进制序列中最后的 i - 1 位，其余补 0</span></li></ol><pre data-language=\"bash\" id=\"cFYLQ\" class=\"ne-codeblock language-bash\"><code>a &#x26; ((1 &#x3C;&#x3C; i) - 1)</code></pre><p id=\"u5082250e\" class=\"ne-p\"><br></p><ol start=\"16\" class=\"ne-ol\"><li id=\"ud562b8fc\" data-lake-index-type=\"0\"><span class=\"ne-text\">将 a 二进制序列中最后 i - 1 位全部置为 0</span></li></ol><pre data-language=\"bash\" id=\"OTje2\" class=\"ne-codeblock language-bash\"><code>a &#x26; ~((1 &#x3C;&#x3C; i) - 1)</code></pre><p id=\"ufe3f5669\" class=\"ne-p\"><br></p><ol start=\"17\" class=\"ne-ol\"><li id=\"uf8319894\" data-lake-index-type=\"0\"><span class=\"ne-text\">判断 a 的二进制序列最高位是否为 1</span></li></ol><pre data-language=\"bash\" id=\"y6jQN\" class=\"ne-codeblock language-bash\"><code>a &#x3C; 0 # 最高位为 1 必然是负数</code></pre><p id=\"u091c94b5\" class=\"ne-p\"><br></p><ol start=\"18\" class=\"ne-ol\"><li id=\"u0a84a17e\" data-lake-index-type=\"0\"><span class=\"ne-text\">在二进制序列中，仅保留最高位的 1，其他设为 0，输出该数</span></li></ol><pre data-language=\"bash\" id=\"HBNmB\" class=\"ne-codeblock language-bash\"><code>a = a | (a >> 1)\na = a | (a >> 2)\na = a | (a >> 4)\na = a | (a >> 8)\na = a | (a >> 16)\nreturn (a + 1) >> 1</code></pre><p id=\"u7beab1ae\" class=\"ne-p\"><br></p><p id=\"u30e1ff2b\" class=\"ne-p\"><span class=\"ne-text\">下面，我们通过一些简单-中等的题目来体验一下位运算解题的巧妙。</span></p><p id=\"u2bd5f4c2\" class=\"ne-p\"><br></p><h3 id=\"DROhD\"><span class=\"ne-text\">题目</span></h3><h4 id=\"dYkhm\"><span class=\"ne-text\">78 - 子集</span></h4><p id=\"u28281460\" class=\"ne-p\"><a href=\"https://leetcode-cn.com/problems/subsets\" data-href=\"https://leetcode-cn.com/problems/subsets\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">https://leetcode-cn.com/problems/subsets</span></a></p><p id=\"u974b951d\" class=\"ne-p\"><span class=\"ne-text\">给你一个整数数组 nums，数组中的元素</span><strong><span class=\"ne-text\">互不相同</span></strong><span class=\"ne-text\">。返回该数组所有可能的子集（幂集）。</span></p><p id=\"u71c7c1ac\" class=\"ne-p\"><span class=\"ne-text\">解集</span><strong><span class=\"ne-text\">不能</span></strong><span class=\"ne-text\">包含重复的子集。你可以按</span><strong><span class=\"ne-text\">任意顺序</span></strong><span class=\"ne-text\">返回解集。</span></p><p id=\"ub4b98bf4\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">示例 1：</span></strong></p><p id=\"u2eb03d60\" class=\"ne-p\"><strong><span class=\"ne-text\">输入：</span></strong><span class=\"ne-text\">nums = [1,2,3]<br></span><strong><span class=\"ne-text\">输出：</span></strong><span class=\"ne-text\">[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span></p><p id=\"u3100fd7c\" class=\"ne-p\"><br></p><p id=\"u0d64c2a8\" class=\"ne-p\"><span class=\"ne-text\">从位运算出发去思考，如果用 0 和 1 标记一个数是否存在于子集中，这样列下来，例子中的输入 [1,2,3] 就会产生下表所示的子集与 0/1 序列的关系，因此我们可以直接遍历这个 0/1 序列，去构建每个子集的数据。</span></p><table id=\"DHpJx\" class=\"ne-table\" style=\"width: 750px\"><tbody><tr style=\"height: 34px\"><td width=\"250\"><p id=\"u44ddfc69\" class=\"ne-p\"><span class=\"ne-text\">0/1</span><span class=\"ne-text\">序列</span></p></td><td width=\"250\"><p id=\"u68745b77\" class=\"ne-p\"><span class=\"ne-text\">子集</span></p></td><td width=\"250\"><p id=\"ud4e486c9\" class=\"ne-p\"><span class=\"ne-text\">0/1</span><span class=\"ne-text\">序列对应的二进制数</span></p></td></tr><tr style=\"height: 34px\"><td width=\"250\"><p id=\"u3c293347\" class=\"ne-p\"><span class=\"ne-text\">000</span></p></td><td width=\"250\"><p id=\"ub69d191d\" class=\"ne-p\"><span class=\"ne-text\">{}</span></p></td><td width=\"250\"><p id=\"u9f3f53dc\" class=\"ne-p\"><span class=\"ne-text\">0</span></p></td></tr><tr style=\"height: 34px\"><td width=\"250\"><p id=\"u0c83a51a\" class=\"ne-p\"><span class=\"ne-text\">001</span></p></td><td width=\"250\"><p id=\"u7229159e\" class=\"ne-p\"><span class=\"ne-text\">{3}</span></p></td><td width=\"250\"><p id=\"uc4fe4cec\" class=\"ne-p\"><span class=\"ne-text\">1</span></p></td></tr><tr style=\"height: 34px\"><td width=\"250\"><p id=\"u6bd5ad2e\" class=\"ne-p\"><span class=\"ne-text\">010</span></p></td><td width=\"250\"><p id=\"u49b7605d\" class=\"ne-p\"><span class=\"ne-text\">{2}</span></p></td><td width=\"250\"><p id=\"uff04d3f3\" class=\"ne-p\"><span class=\"ne-text\">2</span></p></td></tr><tr style=\"height: 34px\"><td width=\"250\"><p id=\"u5ba058e4\" class=\"ne-p\"><span class=\"ne-text\">011</span></p></td><td width=\"250\"><p id=\"u9b8c0ab6\" class=\"ne-p\"><span class=\"ne-text\">{2,3}</span></p></td><td width=\"250\"><p id=\"u78be00ad\" class=\"ne-p\"><span class=\"ne-text\">3</span></p></td></tr><tr style=\"height: 34px\"><td width=\"250\"><p id=\"ueaab9f96\" class=\"ne-p\"><span class=\"ne-text\">100</span></p></td><td width=\"250\"><p id=\"u7dc131b4\" class=\"ne-p\"><span class=\"ne-text\">{1}</span></p></td><td width=\"250\"><p id=\"u11007ca1\" class=\"ne-p\"><span class=\"ne-text\">4</span></p></td></tr><tr style=\"height: 34px\"><td width=\"250\"><p id=\"u2a5a1c23\" class=\"ne-p\"><span class=\"ne-text\">101</span></p></td><td width=\"250\"><p id=\"u53cd3516\" class=\"ne-p\"><span class=\"ne-text\">{1,3}</span></p></td><td width=\"250\"><p id=\"u2ad32c76\" class=\"ne-p\"><span class=\"ne-text\">5</span></p></td></tr><tr style=\"height: 34px\"><td width=\"250\"><p id=\"u60db92e5\" class=\"ne-p\"><span class=\"ne-text\">110</span></p></td><td width=\"250\"><p id=\"ud0dcef02\" class=\"ne-p\"><span class=\"ne-text\">{1,2}</span></p></td><td width=\"250\"><p id=\"u5430e0d3\" class=\"ne-p\"><span class=\"ne-text\">6</span></p></td></tr><tr style=\"height: 34px\"><td width=\"250\"><p id=\"u2913d2dd\" class=\"ne-p\"><span class=\"ne-text\">111</span></p></td><td width=\"250\"><p id=\"u55ac6d4a\" class=\"ne-p\"><span class=\"ne-text\">{1,2,3}</span></p></td><td width=\"250\"><p id=\"u2f9b7393\" class=\"ne-p\"><span class=\"ne-text\">7</span></p></td></tr></tbody></table><p id=\"u6e1f0699\" class=\"ne-p\"><br></p><p id=\"u0b0c6aa8\" class=\"ne-p\"><span class=\"ne-text\">代码的具体实现上，可以通过 1 &#x3C;&#x3C; nums.length 获取子集的总数；可以利用性质 9 取出相应二进制位上的数值用以构建子集的具体结构。具体的代码实现如下：</span></p><pre data-language=\"javascript\" id=\"jFFlU\" class=\"ne-codeblock language-javascript\"><code>/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsets = function(nums) {\n  var res = [], len = nums.length\n  for (var i = 0; i &#x3C; (1 &#x3C;&#x3C; len); i++) {\n    var currSubset = []\n    for (var j = 0; j &#x3C;= len; j++) {\n      if (i &#x26; (1 &#x3C;&#x3C; j)) currSubset.push(nums[j])\n    }\n    res.push(currSubset)\n  }\n  return res\n};</code></pre><p id=\"u24a2dc78\" class=\"ne-p\"><br></p><p id=\"ubd6dee89\" class=\"ne-p\"><span class=\"ne-text\">复杂度分析：</span></p><p id=\"uf439875a\" class=\"ne-p\"><span class=\"ne-text\">时间复杂度为 O(n2</span><sup><span class=\"ne-text\">n</span></sup><span class=\"ne-text\">))，子集的总数为 1 &#x3C;&#x3C; n 即 2</span><sup><span class=\"ne-text\">n</span></sup><span class=\"ne-text\"> 种，得 O(2</span><sup><span class=\"ne-text\">n</span></sup><span class=\"ne-text\">)，构造每个子集时需要遍历一次原数组，得 O(n)。</span></p><p id=\"uc7303653\" class=\"ne-p\"><span class=\"ne-text\">空间复杂度为 O(n)，只有构造子集时使用的临时数组需要额外空间的开销。</span></p><p id=\"ud1a8e40e\" class=\"ne-p\"><br></p><h4 id=\"yRvpU\"><span class=\"ne-text\">136 - 只出现一次的数字</span></h4><p id=\"u1264378c\" class=\"ne-p\"><a href=\"https://leetcode-cn.com/problems/single-number\" data-href=\"https://leetcode-cn.com/problems/single-number\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">https://leetcode-cn.com/problems/single-number</span></a></p><p id=\"ua3dc04af\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">给定一个</span><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">非空</span></strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</span></p><p id=\"u024462c9\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">说明：</span></strong></p><p id=\"udd07468d\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</span></p><p id=\"u6b203e87\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">示例 1:</span></strong></p><p id=\"u81b7dd9c\" class=\"ne-p\"><strong><span class=\"ne-text\">输入:</span></strong><span class=\"ne-text\"> [2,2,1]<br></span><strong><span class=\"ne-text\">输出:</span></strong><span class=\"ne-text\"> 1</span></p><p id=\"u66ff2634\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38); font-size: 13px\">示例 2:</span></strong></p><p id=\"u5ce13a25\" class=\"ne-p\"><strong><span class=\"ne-text\">输入:</span></strong><span class=\"ne-text\"> [4,1,2,1,2]<br></span><strong><span class=\"ne-text\">输出:</span></strong><span class=\"ne-text\"> 4</span></p><p id=\"uf9901564\" class=\"ne-p\"><br></p><p id=\"ue9a9d31e\" class=\"ne-p\"><span class=\"ne-text\">从位运算出发去思考，我们可以找到性质 1、2，两个相等的数异或之后为 0，一个数异或 0 等于它本身，那么将数组中所有元素相异或之后，出现 2 次的数字就会全部被约去，剩下只出现 1 次的数字，代码如下：</span></p><pre data-language=\"javascript\" id=\"kkUMB\" class=\"ne-codeblock language-javascript\"><code>/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singleNumber = function(nums) {\n  var res = 0\n  for (var i = 0; i &#x3C; nums.length; i++) {\n    res ^= nums[i]\n  }\n  return res\n};</code></pre><p id=\"u2bb64df9\" class=\"ne-p\"><br></p><p id=\"u5f8245d6\" class=\"ne-p\"><span class=\"ne-text\">复杂度分析：</span></p><p id=\"u6d29a597\" class=\"ne-p\"><span class=\"ne-text\">时间复杂度为 O(n)，因为只有一次遍历数组操作。</span></p><p id=\"u1e30703e\" class=\"ne-p\"><span class=\"ne-text\">空间复杂度为 O(1)，没有额外空间开销。</span></p><p id=\"u717329c3\" class=\"ne-p\"><br></p><h4 id=\"nKghx\"><span class=\"ne-text\">169 - 多数元素</span></h4><p id=\"uc677b429\" class=\"ne-p\"><a href=\"https://leetcode-cn.com/problems/majority-element\" data-href=\"https://leetcode-cn.com/problems/majority-element\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">https://leetcode-cn.com/problems/majority-element</span></a></p><p id=\"u2743adaf\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">给定一个大小为 </span><em><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">n </span></em><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">的数组，找到其中的多数元素。多数元素是指在数组中出现次数</span><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">大于 </span></strong><span class=\"ne-text\" style=\"color: rgba(var(--grey-7-rgb)\">⌊ n/2 ⌋</span><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\"> 的元素。</span></p><p id=\"u3ab9e360\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">你可以假设数组是非空的，并且给定的数组总是存在多数元素。</span></p><p id=\"u8cfde3f6\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">示例 1：</span></strong></p><p id=\"u7ec3241e\" class=\"ne-p\"><strong><span class=\"ne-text\">输入：</span></strong><span class=\"ne-text\">[3,2,3]<br></span><strong><span class=\"ne-text\">输出：</span></strong><span class=\"ne-text\">3</span></p><p id=\"u9c3dc50a\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">示例 2：</span></strong></p><p id=\"u74663fbf\" class=\"ne-p\"><strong><span class=\"ne-text\">输入：</span></strong><span class=\"ne-text\">[2,2,1,1,1,2,2]<br></span><strong><span class=\"ne-text\">输出：</span></strong><span class=\"ne-text\">2</span></p><p id=\"u16663d4d\" class=\"ne-p\"><br></p><p id=\"ufd382203\" class=\"ne-p\"><span class=\"ne-text\">题干要求的多数元素，出现次数大于 n/2，从位运算出发去思考可以推断，如果将每一个数字都用 32 位二进制序列列出，去统计每一个二进制位是 0 多还是 1 多，则由每一位的多数元素组成的二进制序列，就可以组成最终那个多数元素的数值。代码如下：</span></p><pre data-language=\"javascript\" id=\"hO1F8\" class=\"ne-codeblock language-javascript\"><code>/**\n * @param {number[]} nums\n * @return {number}\n */\nvar majorityElement = function(nums) {\n  var res = 0, len = nums.length\n  for (var i = 0; i &#x3C; 32; i++) {\n    var ones = 0, zero = 0\n    for (var j = 0; j &#x3C; len; j++) {\n      if (ones > len / 2 || zero > len / 2) {\n        break\n      }\n      if ((nums[j] &#x26; (1 &#x3C;&#x3C; i)) === 0) {\n        zero++\n      } else {\n        ones++\n      }\n    }\n    if (ones > zero) res |= 1 &#x3C;&#x3C; i\n  }\n  return res\n};</code></pre><p id=\"ub1590ef1\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u1f127fa4\" class=\"ne-p\"><span class=\"ne-text\">复杂度分析：</span></p><p id=\"ueee76fc8\" class=\"ne-p\"><span class=\"ne-text\">时间复杂度为 O(n)，一次枚举二进制序列上所有的位（32 位），一次遍历整个数组。</span></p><p id=\"uf4b47534\" class=\"ne-p\"><span class=\"ne-text\">空间复杂度为 O(1)，没有额外空间开销。</span></p><p id=\"u7d33da4f\" class=\"ne-p\"><br></p><h4 id=\"O1IrZ\"><span class=\"ne-text\">342 - 4 的幂</span></h4><p id=\"u2a08e918\" class=\"ne-p\"><a href=\"https://leetcode-cn.com/problems/power-of-four\" data-href=\"https://leetcode-cn.com/problems/power-of-four\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">https://leetcode-cn.com/problems/power-of-four</span></a></p><p id=\"u63def66d\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 </span><span class=\"ne-text\" style=\"color: rgba(var(--grey-7-rgb)\">true</span><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">；否则，返回 </span><span class=\"ne-text\" style=\"color: rgba(var(--grey-7-rgb)\">false</span><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">。</span></p><p id=\"uc37171e1\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">整数 </span><span class=\"ne-text\" style=\"color: rgba(var(--grey-7-rgb)\">n </span><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">是 4 的幂次方需满足：存在整数 </span><span class=\"ne-text\" style=\"color: rgba(var(--grey-7-rgb)\">x </span><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">使得 </span><span class=\"ne-text\" style=\"color: rgba(var(--grey-7-rgb)\">n == 4 ^ x。</span></p><p id=\"ud7d9f786\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">示例 1：</span></strong></p><p id=\"u6e56a1e7\" class=\"ne-p\"><strong><span class=\"ne-text\">输入：</span></strong><span class=\"ne-text\">n = 16<br></span><strong><span class=\"ne-text\">输出：</span></strong><span class=\"ne-text\">true</span></p><p id=\"u286ab641\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">示例 2：</span></strong></p><p id=\"u5b902236\" class=\"ne-p\"><strong><span class=\"ne-text\">输入：</span></strong><span class=\"ne-text\">n = 5<br></span><strong><span class=\"ne-text\">输出：</span></strong><span class=\"ne-text\">false</span></p><p id=\"u6025d7cf\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">示例 3：</span></strong></p><p id=\"u6b7f5943\" class=\"ne-p\"><strong><span class=\"ne-text\">输入：</span></strong><span class=\"ne-text\">n = 1<br></span><strong><span class=\"ne-text\">输出：</span></strong><span class=\"ne-text\">true</span></p><p id=\"u4e178c7e\" class=\"ne-p\"><br></p><p id=\"uec8da32a\" class=\"ne-p\"><span class=\"ne-text\">将 32 个二进制位铺开来看，一个数为 4 的幂意味着有唯一的数字 1 在序列的奇数位置出现。</span></p><pre data-language=\"bash\" id=\"G2NmZ\" class=\"ne-codeblock language-bash\"><code>0000 0000 0000 0000 0000 0000 0000 0001 # 1\n0000 0000 0000 0000 0000 0000 0000 0100 # 4\n0000 0000 0000 0000 0000 0000 0001 0000 # 16\n0000 0000 0000 0000 0000 0000 0100 0000 # 64</code></pre><p id=\"u6b5eacff\" class=\"ne-p\"><span class=\"ne-text\">所以可以利用性质 11，根据消去最后一个 1 之后结果是否为 0，可以判断数字的二进制序列中是否存在唯一的 1；另外在循环中使用 >>> 右移操作符直到数字为 0，可以统计出 1 的初始位置。因此代码如下：</span></p><pre data-language=\"javascript\" id=\"qrzEV\" class=\"ne-codeblock language-javascript\"><code>/**\n * @param {number} n\n * @return {boolean}\n */\nvar isPowerOfFour = function(n) {\n  // 是否唯一的 1\n  var onlyOne = (n &#x26; (n - 1)) === 0\n  // 求 1 的位置\n  var pos = 0, temp = n\n  while (temp !== 0) {\n    temp >>>= 1\n    pos++\n  }\n  // 若有唯一的 1，且 1 是奇数，则认为其是 4 的幂\n  return onlyOne &#x26;&#x26; ((pos &#x26; 1) !== 0)\n};</code></pre><p id=\"u0cc071af\" class=\"ne-p\"><br></p><p id=\"ub9baac2e\" class=\"ne-p\"><span class=\"ne-text\">复杂度分析：</span></p><p id=\"u2ab14684\" class=\"ne-p\"><span class=\"ne-text\">时间复杂度为 O(1)，解中唯一的循环，是在二进制序列上移动，移动到数字本身为 0，即可求出唯一 1 原来的位置。</span></p><p id=\"ud107c150\" class=\"ne-p\"><span class=\"ne-text\">空间复杂度为 O(1)，没有额外空间开销。</span></p><p id=\"ufe04a20b\" class=\"ne-p\"><br></p><h4 id=\"J2fBK\"><span class=\"ne-text\">461 - 汉明距离</span></h4><p id=\"u073d15e0\" class=\"ne-p\"><a href=\"https://leetcode-cn.com/problems/hamming-distance\" data-href=\"https://leetcode-cn.com/problems/hamming-distance\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">https://leetcode-cn.com/problems/hamming-distance</span></a></p><p id=\"u5c3574ab\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">两个整数之间的</span><a href=\"https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB\" data-href=\"https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">汉明距离</span></a><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">指的是这两个数字对应二进制位不同的位置的数目。</span></p><p id=\"u157daa3e\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">给出两个整数 </span><span class=\"ne-text\" style=\"color: rgba(var(--grey-7-rgb)\">x </span><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">和 </span><span class=\"ne-text\" style=\"color: rgba(var(--grey-7-rgb)\">y</span><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">，计算它们之间的汉明距离。</span></p><p id=\"ub30fd67d\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">注意：</span></strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">0 ≤ </span><span class=\"ne-text\" style=\"color: rgba(var(--grey-7-rgb)\">x</span><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">, </span><span class=\"ne-text\" style=\"color: rgba(var(--grey-7-rgb)\">y </span><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">&#x3C; 231.</span></p><p id=\"ubce40f69\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">示例:</span></strong></p><p id=\"u76c95254\" class=\"ne-p\"><strong><span class=\"ne-text\">输入:</span></strong><span class=\"ne-text\"> x = 1, y = 4<br></span><strong><span class=\"ne-text\">输出:</span></strong><span class=\"ne-text\"> 2</span></p><p id=\"uc0bb2333\" class=\"ne-p\"><span class=\"ne-text\">上面的箭头指出了对应二进制位不同的位置。</span></p><p id=\"ue9bc9909\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"ud30d1726\" class=\"ne-p\"><span class=\"ne-text\">首先列出示例中两个数的二进制序列：</span></p><pre data-language=\"bash\" id=\"UDOaA\" class=\"ne-codeblock language-bash\"><code>0000 0000 0000 0000 0000 0000 0000 0001\n0000 0000 0000 0000 0000 0000 0000 0100</code></pre><p id=\"ubcfe9919\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u74da1a36\" class=\"ne-p\"><span class=\"ne-text\">很明显，只要把两数相异或，二进制位不同的位在结果中即为 1，再使用性质 11 统计结果中 1 的个数，即可得解。因此代码如下：</span></p><pre data-language=\"javascript\" id=\"OfGKc\" class=\"ne-codeblock language-javascript\"><code>/**\n * @param {number} x\n * @param {number} y\n * @return {number}\n */\nvar hammingDistance = function(x, y) {\n  var xorRes = x ^ y, count = 0\n  while (xorRes !== 0) {\n    xorRes &#x26;= (xorRes - 1)\n    count++\n  }\n  return count\n};</code></pre><p id=\"uf8386967\" class=\"ne-p\"><br></p><p id=\"udd7e35d3\" class=\"ne-p\"><span class=\"ne-text\">时间复杂度与空间复杂度均为 O(1)。</span></p><p id=\"uf28e563d\" class=\"ne-p\"><br></p><h4 id=\"qNFub\"><span class=\"ne-text\">1356 - 根据数字二进制下 1 的数目排序</span></h4><p id=\"u5581b511\" class=\"ne-p\"><a href=\"https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits\" data-href=\"https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits</span></a></p><p id=\"u11ca3c8d\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">给你一个整数数组 </span><span class=\"ne-text\" style=\"color: rgba(var(--grey-7-rgb)\">arr</span><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\"> 。请你将数组中的元素按照其二进制表示中数字 </span><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">1 </span></strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">的数目升序排序。</span></p><p id=\"u283d3ca8\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">如果存在多个数字二进制中 </span><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">1</span></strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\"> 的数目相同，则必须将它们按照数值大小升序排列。</span></p><p id=\"u2215dada\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">请你返回排序后的数组。</span></p><p id=\"ue101ce52\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(38, 38, 38)\">示例 1：</span></strong></p><p id=\"u06eb1016\" class=\"ne-p\"><strong><span class=\"ne-text\">输入：</span></strong><span class=\"ne-text\">arr = [0,1,2,3,4,5,6,7,8]<br></span><strong><span class=\"ne-text\">输出：</span></strong><span class=\"ne-text\">[0,1,2,4,8,3,5,6,7]</span></p><p id=\"u064bcb16\" class=\"ne-p\"><strong><span class=\"ne-text\">解释：</span></strong><span class=\"ne-text\">[0] 是唯一一个有 0 个 1 的数。<br></span><span class=\"ne-text\">[1,2,4,8] 都有 1 个 1。<br></span><span class=\"ne-text\">[3,5,6] 有 2 个 1。</span></p><p id=\"u00f79758\" class=\"ne-p\"><span class=\"ne-text\">[7] 有 3 个 1 。<br></span><span class=\"ne-text\">按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]</span></p><p id=\"u8a171db3\" class=\"ne-p\"><br></p><p id=\"ufc63bfd1\" class=\"ne-p\"><span class=\"ne-text\">最暴力的方法，直接调用语言自带的排序函数，对比函数中则使用性质 11 统计 value1 和 value2 二进制序列中 1 的个数，最终 1 的个数不同时按照 1 的个数升序，相同时按照数值大小升序。因此代码如下：</span></p><pre data-language=\"javascript\" id=\"vOOj7\" class=\"ne-codeblock language-javascript\"><code>/**\n * @param {number[]} arr\n * @return {number[]}\n */\nvar sortByBits = function(arr) {\n  return arr.sort((v1, v2) => {\n    var temp1 = v1, temp2 = v2, count1 = 0, count2 = 0\n    while (temp1 !== 0) {\n      temp1 &#x26;= temp1 - 1\n      count1++\n    }\n    while (temp2 !== 0) {\n      temp2 &#x26;= temp2 - 1\n      count2++\n    }\n    return count1 === count2 ? v1 - v2 : count1 - count2\n  })\n};</code></pre><p id=\"u73b6d5d4\" class=\"ne-p\"><br></p><p id=\"ub91e3a21\" class=\"ne-p\"><span class=\"ne-text\">复杂度分析：</span></p><p id=\"uc71a6dc0\" class=\"ne-p\"><span class=\"ne-text\">开销全部来自于系统自带的排序函数，JS 的 Array.prototype.sort 是使用快排实现的，因此复杂度与快排一致，时间复杂度为 O(nlog</span><sub><span class=\"ne-text\">n</span></sub><span class=\"ne-text\">)，空间复杂度为 O(n)。</span></p><p id=\"u7534c2ac\" class=\"ne-p\"><br></p><h4 id=\"H7d7d\"><span class=\"ne-text\">总结</span></h4><p id=\"u54ce3924\" class=\"ne-p\"><span class=\"ne-text\">在上面列出的题目中，我认为 </span><a href=\"https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#ooSe4\" data-href=\"https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#ooSe4\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">78 - 子集</span></a><span class=\"ne-text\"> 和 </span><a href=\"https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#gmonn\" data-href=\"https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#gmonn\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">169 - 多数元素</span></a><span class=\"ne-text\"> 是很有代表性的题目，这类问题的共通性在于，题干都可以拆分为多个是非问题的组合。</span><a href=\"https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#ooSe4\" data-href=\"https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#ooSe4\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">78 - 子集</span></a><span class=\"ne-text\"> 是被拆分为了数组中的每一个数是否存在的问题的集合；而 </span><a href=\"https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#gmonn\" data-href=\"https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#gmonn\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">169 - 多数元素</span></a><span class=\"ne-text\"> 则是被拆分为统计二进制序列中每一个位置上的多数值。因此在解题时可以从这个方向进行思考。</span></p><p id=\"u95a7a0b0\" class=\"ne-p\"><span class=\"ne-text\"></span></p><h3 id=\"aZgl9\"><span class=\"ne-text\">位掩码</span></h3><p id=\"u733984be\" class=\"ne-p\"><span class=\"ne-text\">虽然本篇是从算法角度切入，但是位运算在日常开发中还有一些实用的小技巧，比如知名 JS 函数库 Lodash 中使用到的位掩码技术。</span></p><p id=\"ua948ac3f\" class=\"ne-p\"><br></p><p id=\"ub135ef7b\" class=\"ne-p\"><span class=\"ne-text\">位掩码通常用于处理多个布尔变量的组合，在 Lodash 中，JS 对象拷贝相关函数的基础函数 baseClone 就使用了位掩码来控制不同的克隆方式。让我们直接来解读一下它的核心代码。</span></p><p id=\"u02546a62\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u39466a1e\" class=\"ne-p\"><span class=\"ne-text\">首先，我们需要几个预设的掩码，它们都是由一个仅有唯一 1 的二进制序列组成的（因此它们都是 2 的幂），每个二进制位代表一个开关，而后续的代码中，则可以通过某些二进制运算，来表示各种关系的不同组合：</span></p><pre data-language=\"javascript\" id=\"nYrA6\" class=\"ne-codeblock language-javascript\"><code>const CLONE_DEEP_FLAG = 1    // 0001：深拷贝\nconst CLONE_FLAT_FLAG = 2    // 0010：拷贝原型链标志位\nconst CLONE_SYMBOLS_FLAG = 4 // 0100：拷贝 Symbol 类型标志位</code></pre><p id=\"u43b41a08\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u8b21abba\" class=\"ne-p\"><span class=\"ne-text\">然后是 cloneDeep 的代码，它调用了 baseClone，并传入了掩码 </span><code class=\"ne-code\"><span class=\"ne-text\">CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG</span></code><span class=\"ne-text\">，这个表达式运算的结果是 5，也就是二进制的 0101。我们发现，通过 | 运算将两个掩码组合，就可以让两个标志位同时变成 1：</span></p><pre data-language=\"javascript\" id=\"z6yw1\" class=\"ne-codeblock language-javascript\"><code>function cloneDeep(value) {\n  // cloneDeep 需要深克隆和克隆 Symbol\n  // 1 | 4 -> 0001 | 0100 -> 0101\n  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG)\n}</code></pre><p id=\"u02276fd1\" class=\"ne-p\"><br></p><p id=\"u90195d37\" class=\"ne-p\"><span class=\"ne-text\">最后找到了 baseClone 的核心代码，这里将刚才传入的 </span><code class=\"ne-code\"><span class=\"ne-text\">CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG</span></code><span class=\"ne-text\"> 和三个掩码分别进行 &#x26; 操作，突然发现这里正是用到了</span><a href=\"https://www.yuque.com/bufeidefeiyang/blog/rih5mgvkl294kred#XFuX7\" data-href=\"#XFuX7\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">常用性质</span></a><span class=\"ne-text\">中的性质 3！这时会发现，我们只要将传入的掩码 bitmask 与各个标志的掩码进行 &#x26; 操作，则如果 bitmask 中相应的二进制位为 1，则结果就是该掩码的值；如果 bitmask 中相应的二进制位为 0，则结果就是 0。这样就可以为每个标志位生成其对应的布尔变量，用于后续的函数判断了：</span></p><pre data-language=\"javascript\" id=\"Ef269\" class=\"ne-codeblock language-javascript\"><code>// 刚才我们传入的值是 1 | 4 = 5\n// 因此 isDeep 的值即为 5 &#x26; 1 = 1\n//   0101\n// &#x26; 0001\n// ------\n//   0001\n// 可以发现，当传入掩码的二进制序列中存在相应标志位时\n// &#x26; 操作就会直接返回当前标志位的掩码\n// 这样，如果返回的结果为 0，则意味着掩码中不存在相应标志位，结果为 0 == false\n// 如果返回的结果大于 0，则意味着掩码中存在相应标志位，结果为任意数字，转换为布尔值为 true\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  const isDeep = bitmask &#x26; CLONE_DEEP_FLAG\n  const isFlat = bitmask &#x26; CLONE_FLAT_FLAG\n  const isFull = bitmask &#x26; CLONE_SYMBOLS_FLAG\n  ...\n}</code></pre><p id=\"0eb510c38385bc470bfff82ac79ecd62\" class=\"ne-p\"><br></p><h3 id=\"RTGHj\"><span class=\"ne-text\">References</span></h3><ul class=\"ne-ul\"><li id=\"uc950f443\" data-lake-index-type=\"0\"><a href=\"https://www.zhihu.com/question/38206659/answer/392527806\" data-href=\"https://www.zhihu.com/question/38206659/answer/392527806\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">位运算有什么奇技淫巧？ - 伍亦勤的回答 - 知乎</span></a></li><li id=\"ubd2978bc\" data-lake-index-type=\"0\"><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6\" data-href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">位运算符 - MDN</span></a></li><li id=\"u425487d1\" data-lake-index-type=\"0\"><a href=\"https://github.com/yygmind/blog/issues/31\" data-href=\"https://github.com/yygmind/blog/issues/31\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">【进阶4-4期】Lodash是如何实现深拷贝的 - 木易杨</span></a></li></ul></div></body></html>","body_lake":"<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"viewport\" content=\"fixed\" /><h1 data-lake-id=\"sVa17\" id=\"sVa17\"><span data-lake-id=\"uc8af6845\" id=\"uc8af6845\">位运算的算法应用</span></h1><h3 data-lake-id=\"Iucu7\" id=\"Iucu7\"><span data-lake-id=\"u764a0283\" id=\"u764a0283\">基本介绍</span></h3><p data-lake-id=\"u1c44377e\" id=\"u1c44377e\"><span data-lake-id=\"ud3a1bf26\" id=\"ud3a1bf26\">作为算法题的一个大类，位运算相关的题目常常出现在各大公司的面试/笔试题中，下面先说说位运算的基本原理。</span></p><p data-lake-id=\"ud4f433d3\" id=\"ud4f433d3\"><br></p><p data-lake-id=\"u8d638f3f\" id=\"u8d638f3f\"><span data-lake-id=\"u954e5451\" id=\"u954e5451\">位运算使得计算机可以直接对每个比特位进行计算，效率会非常的高。</span></p><p data-lake-id=\"u8eaa65a5\" id=\"u8eaa65a5\"><br></p><p data-lake-id=\"ub7943adc\" id=\"ub7943adc\"><span data-lake-id=\"ube2b3423\" id=\"ube2b3423\">在 JS 中，位运算会将操作数当作 32 位的二进制串进行计算，如果二进制串超过 32 位，则只保留最后的 32 位进行计算，如：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%2211100110111110100000000000000110000000000001%20%23%20%E8%BE%93%E5%85%A5%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%B2%5Cn%20%20%20%20%20%20%20%20%20%20%20%2010100000000000000110000000000001%20%23%20%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%B2%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22SE8ru%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"ud7b727ee\" id=\"ud7b727ee\"><br></p><p data-lake-id=\"u1861599c\" id=\"u1861599c\"><span data-lake-id=\"u0f153555\" id=\"u0f153555\">在 JS 中，位运算有 7 种运算符：</span></p><p data-lake-id=\"uaa709a72\" id=\"uaa709a72\"><br></p><ol list=\"u139c874c\"><li fid=\"u9812423d\" data-lake-id=\"u4f0e2f25\" id=\"u4f0e2f25\"><span data-lake-id=\"ub7257cc5\" id=\"ub7257cc5\">按位与（a &amp; b）：在 a, b 的位表示中，每一个对应的位都为 1 则返回 1，否则返回 0</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%22%23%2015%20%26%209%20-%3E%209%5Cn%20%200000%200000%200000%200000%200000%200000%200000%201111%5Cn%26%200000%200000%200000%200000%200000%200000%200000%201001%5Cn%20%20---------------------------------------%5Cn%20%200000%200000%200000%200000%200000%200000%200000%201001%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22Qkrsx%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u16b492fd\" id=\"u16b492fd\"><br></p><ol list=\"u5f8acfe1\" start=\"2\"><li fid=\"u3e9206c8\" data-lake-id=\"u823ca447\" id=\"u823ca447\"><span data-lake-id=\"ua1bf49d1\" id=\"ua1bf49d1\">按位或（a | b）：在 a, b 的位表示中，每一个对应的位，只要有一个为 1 则返回 1，否则返回 0</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%22%23%2015%20%7C%209%20-%3E%2015%5Cn%20%200000%200000%200000%200000%200000%200000%200000%201111%5Cn%7C%200000%200000%200000%200000%200000%200000%200000%201001%5Cn%20%20---------------------------------------%5Cn%20%200000%200000%200000%200000%200000%200000%200000%201111%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22JTgrM%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"ue15e2835\" id=\"ue15e2835\"><br></p><ol list=\"u382edf85\" start=\"3\"><li fid=\"u7dc96f49\" data-lake-id=\"ue71095b2\" id=\"ue71095b2\"><span data-lake-id=\"u27637233\" id=\"u27637233\">按位异或（a ^ b）：在 a, b 的位表示中，每一个对应的位，两个不相同则返回 1，相同则返回 0</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%22%23%2015%20%5E%209%20-%3E%206%5Cn%20%200000%200000%200000%200000%200000%200000%200000%201111%5Cn%7C%200000%200000%200000%200000%200000%200000%200000%201001%5Cn%20%20---------------------------------------%5Cn%20%200000%200000%200000%200000%200000%200000%200000%200110%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22AenYs%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u91c29dcb\" id=\"u91c29dcb\"><br></p><ol list=\"u4e76a23a\" start=\"4\"><li fid=\"u509bdae2\" data-lake-id=\"u684452ea\" id=\"u684452ea\"><span data-lake-id=\"ub99d4ae0\" id=\"ub99d4ae0\">按位非（~a）：反转被操作数的位，即将每一位的 0 转为 1，1 转为 0</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%22%23%20~15%20-%3E%20-16%5Cn~%200000%200000%200000%200000%200000%200000%200000%201111%5Cn%20%20---------------------------------------%5Cn%20%201111%201111%201111%201111%201111%201111%201111%200000%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22bSQvX%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"ufeab8f23\" id=\"ufeab8f23\"><br></p><ol list=\"u4dd6c766\" start=\"5\"><li fid=\"u385a1392\" data-lake-id=\"u0e14f280\" id=\"u0e14f280\"><span data-lake-id=\"u369e2749\" id=\"u369e2749\">左移（a &lt;&lt; b）：将 a 的二进制串向左移动 b 位，右边移入 0</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%22%23%209%20%3C%3C%202%20-%3E%2036%5Cn%3C%3C%20%200000%200000%200000%200000%200000%200000%200000%201001%5Cn%20%20%20%20---------------------------------------%5Cn%20%20%20%200000%200000%200000%200000%200000%200000%200010%200100%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22wuNyp%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u0545f9a9\" id=\"u0545f9a9\"><br></p><p data-lake-id=\"u0c06431d\" id=\"u0c06431d\"><span data-lake-id=\"u7a077762\" id=\"u7a077762\">6. 有符号右移（a &gt;&gt; b）：把 a 的二进制表示向右移动 b 位，向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。这种右移由于保留最左侧的二进制位，因此可以保留数字原本的正负符号</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%22%23%209%20%3E%3E%202%20-%3E%202%5Cn%3E%3E%20%200000%200000%200000%200000%200000%200000%200000%201001%5Cn%20%20%20%20---------------------------------------%5Cn%20%20%20%200000%200000%200000%200000%200000%200000%200010%200010%5Cn%23%20-9%20%3E%3E%202%20-%3E%20-3%5Cn%3E%3E%20%201111%201111%201111%201111%201111%201111%201111%200111%5Cn%20%20%20%20---------------------------------------%5Cn%20%20%20%201111%201111%201111%201111%201111%201111%201111%201101%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22zD0S8%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u79fd751e\" id=\"u79fd751e\"><br></p><p data-lake-id=\"ud31e3f62\" id=\"ud31e3f62\"><span data-lake-id=\"u7405b7d8\" id=\"u7405b7d8\">7. 无符号右移（a &gt;&gt;&gt; b）：把 a 的二进制表示向右移动 b 位，向右被移出的位被丢弃，左边空出的位全部填充为 0。这种右移由于左侧直接补 0，因此生成的数字必然是非负数</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%22%23%2019%20%3E%3E%3E%202%20-%3E%204%5Cn%3E%3E%3E%20%200000%200000%200000%200000%200000%200000%200001%200011%5Cn%20%20%20%20%20---------------------------------------%5Cn%20%20%20%20%200000%200000%200000%200000%200000%200000%200010%200010%5Cn%23%20-19%20%3E%3E%3E%202%20-%3E%201073741819%5Cn%3E%3E%3E%20%201111%201111%201111%201111%201111%201111%201110%201101%5Cn%20%20%20%20%20---------------------------------------%5Cn%20%20%20%20%200011%201111%201111%201111%201111%201111%201111%200011%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22SlQN1%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"ud0bf4c39\" id=\"ud0bf4c39\"><br></p><h3 data-lake-id=\"xxuVW\" id=\"xxuVW\"><span data-lake-id=\"u3cf12d31\" id=\"u3cf12d31\">常用性质</span></h3><p data-lake-id=\"u4d3a64fa\" id=\"u4d3a64fa\"><span data-lake-id=\"ubf6ce3de\" id=\"ubf6ce3de\">在使用位运算技巧解的算法题中，有以下这些常用的性质：</span></p><p data-lake-id=\"ubb626212\" id=\"ubb626212\"><br></p><ol list=\"u23904bee\"><li fid=\"u3115bba7\" data-lake-id=\"u3fb5476e\" id=\"u3fb5476e\"><span data-lake-id=\"u4c35744b\" id=\"u4c35744b\">a 与自身之间的操作</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%22a%20%26%20a%20%3D%20a%5Cna%20%7C%20a%20%3D%20a%5Cna%20%5E%20a%20%3D%200%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22arLYF%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"uff01915b\" id=\"uff01915b\"><br></p><ol list=\"ubdf81a95\" start=\"2\"><li fid=\"u04d0b705\" data-lake-id=\"u411dd390\" id=\"u411dd390\"><span data-lake-id=\"uab1cbfc1\" id=\"uab1cbfc1\">a 与 0 之间的操作</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%22a%20%26%200%20%3D%200%5Cna%20%7C%200%20%3D%20a%5Cna%20%5E%200%20%3D%20a%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22o3kc0%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u720b807a\" id=\"u720b807a\"><br></p><ol list=\"uf3211c11\" start=\"3\"><li fid=\"u667a2339\" data-lake-id=\"ua0dd6598\" id=\"ua0dd6598\"><span data-lake-id=\"u304ecc5b\" id=\"u304ecc5b\">按位与、按位或的还原计算</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%22a%20%7C%20(%20a%20%26%20b%20)%20%3D%20a%5Cna%20%26%20(%20a%20%7C%20b%20)%20%3D%20a%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22fuArK%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u251dc115\" id=\"u251dc115\"><br></p><ol list=\"u19e0ca9c\" start=\"4\"><li fid=\"u375d8065\" data-lake-id=\"ubda7c069\" id=\"ubda7c069\"><span data-lake-id=\"ud23730b5\" id=\"ud23730b5\">通过异或完成变量值交换</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%22a%20%5E%3D%20b%5Cnb%20%5E%3D%20a%5Cna%20%5E%3D%20b%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22Xn9kL%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"ub4ecd415\" id=\"ub4ecd415\"><br></p><ol list=\"u4400eee7\" start=\"5\"><li fid=\"ub6415daa\" data-lake-id=\"u7b658c74\" id=\"u7b658c74\"><span data-lake-id=\"ue9683deb\" id=\"ue9683deb\">判断奇偶（通过 &amp; 1 取出最后一个二进制位以达到模 2 的效果）</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%22%23%20%E4%BD%8D%E8%BF%90%E7%AE%97%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98%5Cna%20%26%201%20%3D%3D%3D%20a%20%25%202%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22e6tTC%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"udc81b3b2\" id=\"udc81b3b2\"><br></p><ol list=\"ud73fb7e2\" start=\"6\"><li fid=\"u82fd3f32\" data-lake-id=\"u47924ae6\" id=\"u47924ae6\"><span data-lake-id=\"u0bc3312c\" id=\"u0bc3312c\">比较两值是否相等（a ^ a === 0）</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%22a%20%5E%20b%20%3D%3D%3D%200%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22V0M5G%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"udd5fa9a3\" id=\"udd5fa9a3\"><br></p><ol list=\"udd624ca4\" start=\"7\"><li fid=\"u077279be\" data-lake-id=\"u91fd07ef\" id=\"u91fd07ef\"><span data-lake-id=\"ua3d93c00\" id=\"ua3d93c00\">将第 i + 1 个二进制位设为 1</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%22a%20%7C%3D%201%20%3C%3C%20i%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22ZdlbV%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><ol list=\"ued7608b4\" start=\"8\"><li fid=\"u31c2e660\" data-lake-id=\"u1cf8c836\" id=\"u1cf8c836\"><span data-lake-id=\"u6e40b1fb\" id=\"u6e40b1fb\">将第 i + 1 个二进制位设为 0</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%22a%20%26%3D%20~(1%20%3C%3C%20i)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22H6SAG%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u5b0c7c4a\" id=\"u5b0c7c4a\"><br></p><ol list=\"u2a30b52f\" start=\"9\"><li fid=\"udcc1021c\" data-lake-id=\"u44880742\" id=\"u44880742\"><span data-lake-id=\"u90c858af\" id=\"u90c858af\">取出第 i + 1 个二进制位上的数值</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%22a%20%26%20(1%20%3C%3C%20i)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22mX0SU%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><ol list=\"u351c2f8f\" start=\"10\"><li fid=\"u1d60a057\" data-lake-id=\"ua2c5ab02\" id=\"ua2c5ab02\"><span data-lake-id=\"u36b9fae4\" id=\"u36b9fae4\">在 a 第 i + 1 个二进制位，插入 b 对应位置的二进制位</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%22a%20%7C%3D%201%20%3C%3C%20i%5Cna%20%26%20(b%20%26%201%20%3C%3C%20i)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22TvVrJ%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u40cc7c19\" id=\"u40cc7c19\"><br></p><ol list=\"ub9c11b1e\" start=\"11\"><li fid=\"uf0049aae\" data-lake-id=\"ub9c4a2f3\" id=\"ub9c4a2f3\"><span data-lake-id=\"udfd3035b\" id=\"udfd3035b\">删除二进制序列中最后一个值为 1 的位置</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%22a%20%26%3D%20(a%20-%201)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22X55hp%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u9c58d752\" id=\"u9c58d752\"><br></p><ol list=\"uf2a8e2ae\" start=\"12\"><li fid=\"ue20d7ece\" data-lake-id=\"ue8e8b963\" id=\"ue8e8b963\"><span data-lake-id=\"ufc337c6a\" id=\"ufc337c6a\">计算 a 的相反数</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%22-a%20%3D%3D%3D%20~a%20%2B%201%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22YOdPx%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u4df312f9\" id=\"u4df312f9\"><br></p><ol list=\"u8dfc5ea7\" start=\"13\"><li fid=\"u1c25bac7\" data-lake-id=\"ua40b55d2\" id=\"ua40b55d2\"><span data-lake-id=\"u0cbba13c\" id=\"u0cbba13c\">保留 a 在二进制位中最后一个 1</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%22a%20%26%3D%20(-a)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22oiVlA%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u138fb043\" id=\"u138fb043\"><br></p><ol list=\"u9fc6f47e\" start=\"14\"><li fid=\"u3e55b3b9\" data-lake-id=\"u0d616c55\" id=\"u0d616c55\"><span data-lake-id=\"u4b0d84e9\" id=\"u4b0d84e9\">生成二进制位全为 1 的数</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%22~0%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22UhCrh%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u5164dee9\" id=\"u5164dee9\"><br></p><ol list=\"u34b7cf55\" start=\"15\"><li fid=\"u7d6842ba\" data-lake-id=\"u86ea175e\" id=\"u86ea175e\"><span data-lake-id=\"ua0c8ac80\" id=\"ua0c8ac80\">保留 a 二进制序列中最后的 i - 1 位，其余补 0</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%22a%20%26%20((1%20%3C%3C%20i)%20-%201)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22cFYLQ%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u5082250e\" id=\"u5082250e\"><br></p><ol list=\"uda6667ef\" start=\"16\"><li fid=\"u86a370e4\" data-lake-id=\"ud562b8fc\" id=\"ud562b8fc\"><span data-lake-id=\"u96b5dfd6\" id=\"u96b5dfd6\">将 a 二进制序列中最后 i - 1 位全部置为 0</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%22a%20%26%20~((1%20%3C%3C%20i)%20-%201)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22OTje2%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"ufe3f5669\" id=\"ufe3f5669\"><br></p><ol list=\"u262c24c7\" start=\"17\"><li fid=\"u153daf36\" data-lake-id=\"uf8319894\" id=\"uf8319894\"><span data-lake-id=\"u9e2fd64f\" id=\"u9e2fd64f\">判断 a 的二进制序列最高位是否为 1</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%22a%20%3C%200%20%23%20%E6%9C%80%E9%AB%98%E4%BD%8D%E4%B8%BA%201%20%E5%BF%85%E7%84%B6%E6%98%AF%E8%B4%9F%E6%95%B0%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22y6jQN%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u091c94b5\" id=\"u091c94b5\"><br></p><ol list=\"u9b7445b7\" start=\"18\"><li fid=\"u83cc14ab\" data-lake-id=\"u0a84a17e\" id=\"u0a84a17e\"><span data-lake-id=\"u2c04e5ed\" id=\"u2c04e5ed\">在二进制序列中，仅保留最高位的 1，其他设为 0，输出该数</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%22a%20%3D%20a%20%7C%20(a%20%3E%3E%201)%5Cna%20%3D%20a%20%7C%20(a%20%3E%3E%202)%5Cna%20%3D%20a%20%7C%20(a%20%3E%3E%204)%5Cna%20%3D%20a%20%7C%20(a%20%3E%3E%208)%5Cna%20%3D%20a%20%7C%20(a%20%3E%3E%2016)%5Cnreturn%20(a%20%2B%201)%20%3E%3E%201%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22HBNmB%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u7beab1ae\" id=\"u7beab1ae\"><br></p><p data-lake-id=\"u30e1ff2b\" id=\"u30e1ff2b\"><span data-lake-id=\"u124be2d1\" id=\"u124be2d1\">下面，我们通过一些简单-中等的题目来体验一下位运算解题的巧妙。</span></p><p data-lake-id=\"u2bd5f4c2\" id=\"u2bd5f4c2\"><br></p><h3 data-lake-id=\"DROhD\" id=\"DROhD\"><span data-lake-id=\"ubfacb632\" id=\"ubfacb632\">题目</span></h3><h4 data-lake-id=\"dYkhm\" id=\"dYkhm\"><span data-lake-id=\"u2ac04de2\" id=\"u2ac04de2\">78 - 子集</span></h4><p data-lake-id=\"u28281460\" id=\"u28281460\"><a href=\"https://leetcode-cn.com/problems/subsets\" target=\"_blank\" data-lake-id=\"u6a8a8b7f\" id=\"u6a8a8b7f\"><span data-lake-id=\"ue77674c3\" id=\"ue77674c3\">https://leetcode-cn.com/problems/subsets</span></a></p><p data-lake-id=\"u974b951d\" id=\"u974b951d\"><span data-lake-id=\"u9e22846d\" id=\"u9e22846d\">给你一个整数数组 nums，数组中的元素</span><strong><span data-lake-id=\"uf74470af\" id=\"uf74470af\">互不相同</span></strong><span data-lake-id=\"u0a46faa5\" id=\"u0a46faa5\">。返回该数组所有可能的子集（幂集）。</span></p><p data-lake-id=\"u71c7c1ac\" id=\"u71c7c1ac\"><span data-lake-id=\"u0212d035\" id=\"u0212d035\">解集</span><strong><span data-lake-id=\"u853c095a\" id=\"u853c095a\">不能</span></strong><span data-lake-id=\"u0ec7f732\" id=\"u0ec7f732\">包含重复的子集。你可以按</span><strong><span data-lake-id=\"uef6f9595\" id=\"uef6f9595\">任意顺序</span></strong><span data-lake-id=\"u857ce99b\" id=\"u857ce99b\">返回解集。</span></p><p data-lake-id=\"ub4b98bf4\" id=\"ub4b98bf4\"><strong><span data-lake-id=\"u935cc9de\" id=\"u935cc9de\" style=\"color: rgb(38, 38, 38)\">示例 1：</span></strong></p><p data-lake-id=\"u2eb03d60\" id=\"u2eb03d60\"><strong><span data-lake-id=\"u976bf412\" id=\"u976bf412\">输入：</span></strong><span data-lake-id=\"u20c7d24f\" id=\"u20c7d24f\">nums = [1,2,3]<br /></span><strong><span data-lake-id=\"u85c4a30d\" id=\"u85c4a30d\">输出：</span></strong><span data-lake-id=\"u26121de6\" id=\"u26121de6\">[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span></p><p data-lake-id=\"u3100fd7c\" id=\"u3100fd7c\"><br></p><p data-lake-id=\"u0d64c2a8\" id=\"u0d64c2a8\"><span data-lake-id=\"uc25cfe15\" id=\"uc25cfe15\">从位运算出发去思考，如果用 0 和 1 标记一个数是否存在于子集中，这样列下来，例子中的输入 [1,2,3] 就会产生下表所示的子集与 0/1 序列的关系，因此我们可以直接遍历这个 0/1 序列，去构建每个子集的数据。</span></p><table data-lake-id=\"DHpJx\" id=\"DHpJx\" margin=\"true\" class=\"lake-table\" style=\"width: 750px\"><colgroup><col width=\"250\"><col width=\"250\"><col width=\"250\"></colgroup><tbody><tr data-lake-id=\"ud5bb071f\" id=\"ud5bb071f\" style=\"height: 34px\"><td data-lake-id=\"uf0b704c3\" id=\"uf0b704c3\"><p data-lake-id=\"u44ddfc69\" id=\"u44ddfc69\"><span data-lake-id=\"ube00775b\" id=\"ube00775b\">0/1</span><span data-lake-id=\"u5d64ca6f\" id=\"u5d64ca6f\">序列</span></p></td><td data-lake-id=\"ubdda06d7\" id=\"ubdda06d7\"><p data-lake-id=\"u68745b77\" id=\"u68745b77\"><span data-lake-id=\"u390e6383\" id=\"u390e6383\">子集</span></p></td><td data-lake-id=\"u71ef21ff\" id=\"u71ef21ff\"><p data-lake-id=\"ud4e486c9\" id=\"ud4e486c9\"><span data-lake-id=\"u6151fe49\" id=\"u6151fe49\">0/1</span><span data-lake-id=\"u45fed735\" id=\"u45fed735\">序列对应的二进制数</span></p></td></tr><tr data-lake-id=\"u22410174\" id=\"u22410174\" style=\"height: 34px\"><td data-lake-id=\"u255877df\" id=\"u255877df\"><p data-lake-id=\"u3c293347\" id=\"u3c293347\"><span data-lake-id=\"u6f4c6e6b\" id=\"u6f4c6e6b\">000</span></p></td><td data-lake-id=\"udd6380c8\" id=\"udd6380c8\"><p data-lake-id=\"ub69d191d\" id=\"ub69d191d\"><span data-lake-id=\"u7ef6b313\" id=\"u7ef6b313\">{}</span></p></td><td data-lake-id=\"uac8ccf44\" id=\"uac8ccf44\"><p data-lake-id=\"u9f3f53dc\" id=\"u9f3f53dc\"><span data-lake-id=\"u00d74fcb\" id=\"u00d74fcb\">0</span></p></td></tr><tr data-lake-id=\"uc015f992\" id=\"uc015f992\" style=\"height: 34px\"><td data-lake-id=\"u44b92e33\" id=\"u44b92e33\"><p data-lake-id=\"u0c83a51a\" id=\"u0c83a51a\"><span data-lake-id=\"u2f017832\" id=\"u2f017832\">001</span></p></td><td data-lake-id=\"u00ab9278\" id=\"u00ab9278\"><p data-lake-id=\"u7229159e\" id=\"u7229159e\"><span data-lake-id=\"u012ca8f1\" id=\"u012ca8f1\">{3}</span></p></td><td data-lake-id=\"u95bc917d\" id=\"u95bc917d\"><p data-lake-id=\"uc4fe4cec\" id=\"uc4fe4cec\"><span data-lake-id=\"u1f2993e6\" id=\"u1f2993e6\">1</span></p></td></tr><tr data-lake-id=\"uf4bdf4f9\" id=\"uf4bdf4f9\" style=\"height: 34px\"><td data-lake-id=\"u0c1ffc71\" id=\"u0c1ffc71\"><p data-lake-id=\"u6bd5ad2e\" id=\"u6bd5ad2e\"><span data-lake-id=\"u6b4937c8\" id=\"u6b4937c8\">010</span></p></td><td data-lake-id=\"u165d9247\" id=\"u165d9247\"><p data-lake-id=\"u49b7605d\" id=\"u49b7605d\"><span data-lake-id=\"ufe3b7e18\" id=\"ufe3b7e18\">{2}</span></p></td><td data-lake-id=\"u935bd7b8\" id=\"u935bd7b8\"><p data-lake-id=\"uff04d3f3\" id=\"uff04d3f3\"><span data-lake-id=\"uff52bc90\" id=\"uff52bc90\">2</span></p></td></tr><tr data-lake-id=\"u11b92b4d\" id=\"u11b92b4d\" style=\"height: 34px\"><td data-lake-id=\"u13538abd\" id=\"u13538abd\"><p data-lake-id=\"u5ba058e4\" id=\"u5ba058e4\"><span data-lake-id=\"u68252ad6\" id=\"u68252ad6\">011</span></p></td><td data-lake-id=\"uf7aead7a\" id=\"uf7aead7a\"><p data-lake-id=\"u9b8c0ab6\" id=\"u9b8c0ab6\"><span data-lake-id=\"uf1d0b574\" id=\"uf1d0b574\">{2,3}</span></p></td><td data-lake-id=\"u0c5de331\" id=\"u0c5de331\"><p data-lake-id=\"u78be00ad\" id=\"u78be00ad\"><span data-lake-id=\"ud86d4a1c\" id=\"ud86d4a1c\">3</span></p></td></tr><tr data-lake-id=\"u77d3c206\" id=\"u77d3c206\" style=\"height: 34px\"><td data-lake-id=\"u27fe9a2a\" id=\"u27fe9a2a\"><p data-lake-id=\"ueaab9f96\" id=\"ueaab9f96\"><span data-lake-id=\"ubfbc2837\" id=\"ubfbc2837\">100</span></p></td><td data-lake-id=\"u66b14eda\" id=\"u66b14eda\"><p data-lake-id=\"u7dc131b4\" id=\"u7dc131b4\"><span data-lake-id=\"u5855408d\" id=\"u5855408d\">{1}</span></p></td><td data-lake-id=\"ufd0f6198\" id=\"ufd0f6198\"><p data-lake-id=\"u11007ca1\" id=\"u11007ca1\"><span data-lake-id=\"u328ef020\" id=\"u328ef020\">4</span></p></td></tr><tr data-lake-id=\"ude835cc7\" id=\"ude835cc7\" style=\"height: 34px\"><td data-lake-id=\"u6dbbee3c\" id=\"u6dbbee3c\"><p data-lake-id=\"u2a5a1c23\" id=\"u2a5a1c23\"><span data-lake-id=\"u1da12fdf\" id=\"u1da12fdf\">101</span></p></td><td data-lake-id=\"uc3356813\" id=\"uc3356813\"><p data-lake-id=\"u53cd3516\" id=\"u53cd3516\"><span data-lake-id=\"ud9ec355c\" id=\"ud9ec355c\">{1,3}</span></p></td><td data-lake-id=\"u5d0e70a1\" id=\"u5d0e70a1\"><p data-lake-id=\"u2ad32c76\" id=\"u2ad32c76\"><span data-lake-id=\"uf9b6ed67\" id=\"uf9b6ed67\">5</span></p></td></tr><tr data-lake-id=\"u9017fb80\" id=\"u9017fb80\" style=\"height: 34px\"><td data-lake-id=\"u43a709b1\" id=\"u43a709b1\"><p data-lake-id=\"u60db92e5\" id=\"u60db92e5\"><span data-lake-id=\"ud378c101\" id=\"ud378c101\">110</span></p></td><td data-lake-id=\"ue43694d0\" id=\"ue43694d0\"><p data-lake-id=\"ud0dcef02\" id=\"ud0dcef02\"><span data-lake-id=\"u3ff7e7a6\" id=\"u3ff7e7a6\">{1,2}</span></p></td><td data-lake-id=\"u208c4692\" id=\"u208c4692\"><p data-lake-id=\"u5430e0d3\" id=\"u5430e0d3\"><span data-lake-id=\"uee06ff6a\" id=\"uee06ff6a\">6</span></p></td></tr><tr data-lake-id=\"u6b154b01\" id=\"u6b154b01\" style=\"height: 34px\"><td data-lake-id=\"ucbc644c5\" id=\"ucbc644c5\"><p data-lake-id=\"u2913d2dd\" id=\"u2913d2dd\"><span data-lake-id=\"u5e56a9fb\" id=\"u5e56a9fb\">111</span></p></td><td data-lake-id=\"u6f8d2dbe\" id=\"u6f8d2dbe\"><p data-lake-id=\"u55ac6d4a\" id=\"u55ac6d4a\"><span data-lake-id=\"u38f9292d\" id=\"u38f9292d\">{1,2,3}</span></p></td><td data-lake-id=\"u522f9d68\" id=\"u522f9d68\"><p data-lake-id=\"u2f9b7393\" id=\"u2f9b7393\"><span data-lake-id=\"uca28d432\" id=\"uca28d432\">7</span></p></td></tr></tbody></table><p data-lake-id=\"u6e1f0699\" id=\"u6e1f0699\"><br></p><p data-lake-id=\"u0b0c6aa8\" id=\"u0b0c6aa8\"><span data-lake-id=\"u1d6c7126\" id=\"u1d6c7126\">代码的具体实现上，可以通过 1 &lt;&lt; nums.length 获取子集的总数；可以利用性质 9 取出相应二进制位上的数值用以构建子集的具体结构。具体的代码实现如下：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F**%5Cn%20*%20%40param%20%7Bnumber%5B%5D%7D%20nums%5Cn%20*%20%40return%20%7Bnumber%5B%5D%5B%5D%7D%5Cn%20*%2F%5Cnvar%20subsets%20%3D%20function(nums)%20%7B%5Cn%20%20var%20res%20%3D%20%5B%5D%2C%20len%20%3D%20nums.length%5Cn%20%20for%20(var%20i%20%3D%200%3B%20i%20%3C%20(1%20%3C%3C%20len)%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20var%20currSubset%20%3D%20%5B%5D%5Cn%20%20%20%20for%20(var%20j%20%3D%200%3B%20j%20%3C%3D%20len%3B%20j%2B%2B)%20%7B%5Cn%20%20%20%20%20%20if%20(i%20%26%20(1%20%3C%3C%20j))%20currSubset.push(nums%5Bj%5D)%5Cn%20%20%20%20%7D%5Cn%20%20%20%20res.push(currSubset)%5Cn%20%20%7D%5Cn%20%20return%20res%5Cn%7D%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22jFFlU%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u24a2dc78\" id=\"u24a2dc78\"><br></p><p data-lake-id=\"ubd6dee89\" id=\"ubd6dee89\"><span data-lake-id=\"ubca1590f\" id=\"ubca1590f\">复杂度分析：</span></p><p data-lake-id=\"uf439875a\" id=\"uf439875a\"><span data-lake-id=\"u7bd4fde5\" id=\"u7bd4fde5\">时间复杂度为 O(n2</span><sup><span data-lake-id=\"u07a43c69\" id=\"u07a43c69\">n</span></sup><span data-lake-id=\"u238e454e\" id=\"u238e454e\">))，子集的总数为 1 &lt;&lt; n 即 2</span><sup><span data-lake-id=\"u5e22af48\" id=\"u5e22af48\">n</span></sup><span data-lake-id=\"u468b61cd\" id=\"u468b61cd\"> 种，得 O(2</span><sup><span data-lake-id=\"u38ae3921\" id=\"u38ae3921\">n</span></sup><span data-lake-id=\"ubce2ccfb\" id=\"ubce2ccfb\">)，构造每个子集时需要遍历一次原数组，得 O(n)。</span></p><p data-lake-id=\"uc7303653\" id=\"uc7303653\"><span data-lake-id=\"uddd98767\" id=\"uddd98767\">空间复杂度为 O(n)，只有构造子集时使用的临时数组需要额外空间的开销。</span></p><p data-lake-id=\"ud1a8e40e\" id=\"ud1a8e40e\"><br></p><h4 data-lake-id=\"yRvpU\" id=\"yRvpU\"><span data-lake-id=\"ua8ba396a\" id=\"ua8ba396a\">136 - 只出现一次的数字</span></h4><p data-lake-id=\"u1264378c\" id=\"u1264378c\"><a href=\"https://leetcode-cn.com/problems/single-number\" target=\"_blank\" data-lake-id=\"u3addd9cf\" id=\"u3addd9cf\"><span data-lake-id=\"uaf6b3e5b\" id=\"uaf6b3e5b\">https://leetcode-cn.com/problems/single-number</span></a></p><p data-lake-id=\"ua3dc04af\" id=\"ua3dc04af\"><span data-lake-id=\"u5fc4c863\" id=\"u5fc4c863\" style=\"color: rgb(38, 38, 38)\">给定一个</span><strong><span data-lake-id=\"u30673072\" id=\"u30673072\" style=\"color: rgb(38, 38, 38)\">非空</span></strong><span data-lake-id=\"u19f97a83\" id=\"u19f97a83\" style=\"color: rgb(38, 38, 38)\">整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</span></p><p data-lake-id=\"u024462c9\" id=\"u024462c9\"><strong><span data-lake-id=\"u57419e9d\" id=\"u57419e9d\" style=\"color: rgb(38, 38, 38)\">说明：</span></strong></p><p data-lake-id=\"udd07468d\" id=\"udd07468d\"><span data-lake-id=\"u8a07df19\" id=\"u8a07df19\" style=\"color: rgb(38, 38, 38)\">你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</span></p><p data-lake-id=\"u6b203e87\" id=\"u6b203e87\"><strong><span data-lake-id=\"u0fb5ea17\" id=\"u0fb5ea17\" style=\"color: rgb(38, 38, 38)\">示例 1:</span></strong></p><p data-lake-id=\"u81b7dd9c\" id=\"u81b7dd9c\"><strong><span data-lake-id=\"u732fd1f6\" id=\"u732fd1f6\">输入:</span></strong><span data-lake-id=\"u27fcd1a6\" id=\"u27fcd1a6\"> [2,2,1]<br /></span><strong><span data-lake-id=\"ue53b5d72\" id=\"ue53b5d72\">输出:</span></strong><span data-lake-id=\"u12c9b5bb\" id=\"u12c9b5bb\"> 1</span></p><p data-lake-id=\"u66ff2634\" id=\"u66ff2634\"><strong><span data-lake-id=\"u7b9ddb7b\" id=\"u7b9ddb7b\" class=\"lake-fontsize-10\" style=\"color: rgb(38, 38, 38)\">示例 2:</span></strong></p><p data-lake-id=\"u5ce13a25\" id=\"u5ce13a25\"><strong><span data-lake-id=\"uf9bdfce8\" id=\"uf9bdfce8\">输入:</span></strong><span data-lake-id=\"u6e92a570\" id=\"u6e92a570\"> [4,1,2,1,2]<br /></span><strong><span data-lake-id=\"u536ab2a3\" id=\"u536ab2a3\">输出:</span></strong><span data-lake-id=\"ud1dac28e\" id=\"ud1dac28e\"> 4</span></p><p data-lake-id=\"uf9901564\" id=\"uf9901564\"><br></p><p data-lake-id=\"ue9a9d31e\" id=\"ue9a9d31e\"><span data-lake-id=\"u29e573e9\" id=\"u29e573e9\">从位运算出发去思考，我们可以找到性质 1、2，两个相等的数异或之后为 0，一个数异或 0 等于它本身，那么将数组中所有元素相异或之后，出现 2 次的数字就会全部被约去，剩下只出现 1 次的数字，代码如下：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F**%5Cn%20*%20%40param%20%7Bnumber%5B%5D%7D%20nums%5Cn%20*%20%40return%20%7Bnumber%7D%5Cn%20*%2F%5Cnvar%20singleNumber%20%3D%20function(nums)%20%7B%5Cn%20%20var%20res%20%3D%200%5Cn%20%20for%20(var%20i%20%3D%200%3B%20i%20%3C%20nums.length%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20res%20%5E%3D%20nums%5Bi%5D%5Cn%20%20%7D%5Cn%20%20return%20res%5Cn%7D%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22kkUMB%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u2bb64df9\" id=\"u2bb64df9\"><br></p><p data-lake-id=\"u5f8245d6\" id=\"u5f8245d6\"><span data-lake-id=\"u363e7641\" id=\"u363e7641\">复杂度分析：</span></p><p data-lake-id=\"u6d29a597\" id=\"u6d29a597\"><span data-lake-id=\"ub67e8c14\" id=\"ub67e8c14\">时间复杂度为 O(n)，因为只有一次遍历数组操作。</span></p><p data-lake-id=\"u1e30703e\" id=\"u1e30703e\"><span data-lake-id=\"u400c5649\" id=\"u400c5649\">空间复杂度为 O(1)，没有额外空间开销。</span></p><p data-lake-id=\"u717329c3\" id=\"u717329c3\"><br></p><h4 data-lake-id=\"nKghx\" id=\"nKghx\"><span data-lake-id=\"uec5729de\" id=\"uec5729de\">169 - 多数元素</span></h4><p data-lake-id=\"uc677b429\" id=\"uc677b429\"><a href=\"https://leetcode-cn.com/problems/majority-element\" target=\"_blank\" data-lake-id=\"ue42a3b7d\" id=\"ue42a3b7d\"><span data-lake-id=\"uee6d6c42\" id=\"uee6d6c42\">https://leetcode-cn.com/problems/majority-element</span></a></p><p data-lake-id=\"u2743adaf\" id=\"u2743adaf\"><span data-lake-id=\"uce2e03c5\" id=\"uce2e03c5\" style=\"color: rgb(38, 38, 38)\">给定一个大小为 </span><em><span data-lake-id=\"u90ee1dbb\" id=\"u90ee1dbb\" style=\"color: rgb(38, 38, 38)\">n </span></em><span data-lake-id=\"u17a3345f\" id=\"u17a3345f\" style=\"color: rgb(38, 38, 38)\">的数组，找到其中的多数元素。多数元素是指在数组中出现次数</span><strong><span data-lake-id=\"ud4b49486\" id=\"ud4b49486\" style=\"color: rgb(38, 38, 38)\">大于 </span></strong><span data-lake-id=\"u37d380b4\" id=\"u37d380b4\" style=\"color: rgba(var(--grey-7-rgb),1)\">⌊ n/2 ⌋</span><span data-lake-id=\"u8b0565d2\" id=\"u8b0565d2\" style=\"color: rgb(38, 38, 38)\"> 的元素。</span></p><p data-lake-id=\"u3ab9e360\" id=\"u3ab9e360\"><span data-lake-id=\"uee1cf23a\" id=\"uee1cf23a\" style=\"color: rgb(38, 38, 38)\">你可以假设数组是非空的，并且给定的数组总是存在多数元素。</span></p><p data-lake-id=\"u8cfde3f6\" id=\"u8cfde3f6\"><strong><span data-lake-id=\"u637ba744\" id=\"u637ba744\" style=\"color: rgb(38, 38, 38)\">示例 1：</span></strong></p><p data-lake-id=\"u7ec3241e\" id=\"u7ec3241e\"><strong><span data-lake-id=\"u8554c834\" id=\"u8554c834\">输入：</span></strong><span data-lake-id=\"u7aaaec76\" id=\"u7aaaec76\">[3,2,3]<br /></span><strong><span data-lake-id=\"ubdf3814b\" id=\"ubdf3814b\">输出：</span></strong><span data-lake-id=\"ufd788f36\" id=\"ufd788f36\">3</span></p><p data-lake-id=\"u9c3dc50a\" id=\"u9c3dc50a\"><strong><span data-lake-id=\"u27039430\" id=\"u27039430\" style=\"color: rgb(38, 38, 38)\">示例 2：</span></strong></p><p data-lake-id=\"u74663fbf\" id=\"u74663fbf\"><strong><span data-lake-id=\"u6c7608b6\" id=\"u6c7608b6\">输入：</span></strong><span data-lake-id=\"ufbec42d9\" id=\"ufbec42d9\">[2,2,1,1,1,2,2]<br /></span><strong><span data-lake-id=\"ua15001d9\" id=\"ua15001d9\">输出：</span></strong><span data-lake-id=\"u91cb8eec\" id=\"u91cb8eec\">2</span></p><p data-lake-id=\"u16663d4d\" id=\"u16663d4d\"><br></p><p data-lake-id=\"ufd382203\" id=\"ufd382203\"><span data-lake-id=\"uc7a426bf\" id=\"uc7a426bf\">题干要求的多数元素，出现次数大于 n/2，从位运算出发去思考可以推断，如果将每一个数字都用 32 位二进制序列列出，去统计每一个二进制位是 0 多还是 1 多，则由每一位的多数元素组成的二进制序列，就可以组成最终那个多数元素的数值。代码如下：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F**%5Cn%20*%20%40param%20%7Bnumber%5B%5D%7D%20nums%5Cn%20*%20%40return%20%7Bnumber%7D%5Cn%20*%2F%5Cnvar%20majorityElement%20%3D%20function(nums)%20%7B%5Cn%20%20var%20res%20%3D%200%2C%20len%20%3D%20nums.length%5Cn%20%20for%20(var%20i%20%3D%200%3B%20i%20%3C%2032%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20var%20ones%20%3D%200%2C%20zero%20%3D%200%5Cn%20%20%20%20for%20(var%20j%20%3D%200%3B%20j%20%3C%20len%3B%20j%2B%2B)%20%7B%5Cn%20%20%20%20%20%20if%20(ones%20%3E%20len%20%2F%202%20%7C%7C%20zero%20%3E%20len%20%2F%202)%20%7B%5Cn%20%20%20%20%20%20%20%20break%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20if%20((nums%5Bj%5D%20%26%20(1%20%3C%3C%20i))%20%3D%3D%3D%200)%20%7B%5Cn%20%20%20%20%20%20%20%20zero%2B%2B%5Cn%20%20%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20ones%2B%2B%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%20%20if%20(ones%20%3E%20zero)%20res%20%7C%3D%201%20%3C%3C%20i%5Cn%20%20%7D%5Cn%20%20return%20res%5Cn%7D%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22hO1F8%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"ub1590ef1\" id=\"ub1590ef1\"><span data-lake-id=\"u50bfa876\" id=\"u50bfa876\">​</span><br></p><p data-lake-id=\"u1f127fa4\" id=\"u1f127fa4\"><span data-lake-id=\"ufa7eab6a\" id=\"ufa7eab6a\">复杂度分析：</span></p><p data-lake-id=\"ueee76fc8\" id=\"ueee76fc8\"><span data-lake-id=\"u9beae7b4\" id=\"u9beae7b4\">时间复杂度为 O(n)，一次枚举二进制序列上所有的位（32 位），一次遍历整个数组。</span></p><p data-lake-id=\"uf4b47534\" id=\"uf4b47534\"><span data-lake-id=\"u97dab4a7\" id=\"u97dab4a7\">空间复杂度为 O(1)，没有额外空间开销。</span></p><p data-lake-id=\"u7d33da4f\" id=\"u7d33da4f\"><br></p><h4 data-lake-id=\"O1IrZ\" id=\"O1IrZ\"><span data-lake-id=\"u001eb8d8\" id=\"u001eb8d8\">342 - 4 的幂</span></h4><p data-lake-id=\"u2a08e918\" id=\"u2a08e918\"><a href=\"https://leetcode-cn.com/problems/power-of-four\" target=\"_blank\" data-lake-id=\"u01a54153\" id=\"u01a54153\"><span data-lake-id=\"u15d4b9f7\" id=\"u15d4b9f7\">https://leetcode-cn.com/problems/power-of-four</span></a></p><p data-lake-id=\"u63def66d\" id=\"u63def66d\"><span data-lake-id=\"u753d6b8c\" id=\"u753d6b8c\" style=\"color: rgb(38, 38, 38)\">给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 </span><span data-lake-id=\"uce04ecf4\" id=\"uce04ecf4\" style=\"color: rgba(var(--grey-7-rgb),1)\">true</span><span data-lake-id=\"u30838237\" id=\"u30838237\" style=\"color: rgb(38, 38, 38)\">；否则，返回 </span><span data-lake-id=\"uc88a3328\" id=\"uc88a3328\" style=\"color: rgba(var(--grey-7-rgb),1)\">false</span><span data-lake-id=\"u375b0ec5\" id=\"u375b0ec5\" style=\"color: rgb(38, 38, 38)\">。</span></p><p data-lake-id=\"uc37171e1\" id=\"uc37171e1\"><span data-lake-id=\"u758e9895\" id=\"u758e9895\" style=\"color: rgb(38, 38, 38)\">整数 </span><span data-lake-id=\"ua3ac2864\" id=\"ua3ac2864\" style=\"color: rgba(var(--grey-7-rgb),1)\">n </span><span data-lake-id=\"uf8bcbe5d\" id=\"uf8bcbe5d\" style=\"color: rgb(38, 38, 38)\">是 4 的幂次方需满足：存在整数 </span><span data-lake-id=\"ueeb57767\" id=\"ueeb57767\" style=\"color: rgba(var(--grey-7-rgb),1)\">x </span><span data-lake-id=\"u863d7dc8\" id=\"u863d7dc8\" style=\"color: rgb(38, 38, 38)\">使得 </span><span data-lake-id=\"u9947a9a0\" id=\"u9947a9a0\" style=\"color: rgba(var(--grey-7-rgb),1)\">n == 4 ^ x。</span></p><p data-lake-id=\"ud7d9f786\" id=\"ud7d9f786\"><strong><span data-lake-id=\"u8ba666cb\" id=\"u8ba666cb\" style=\"color: rgb(38, 38, 38)\">示例 1：</span></strong></p><p data-lake-id=\"u6e56a1e7\" id=\"u6e56a1e7\"><strong><span data-lake-id=\"u523c636a\" id=\"u523c636a\">输入：</span></strong><span data-lake-id=\"u431e88d9\" id=\"u431e88d9\">n = 16<br /></span><strong><span data-lake-id=\"u57a168b6\" id=\"u57a168b6\">输出：</span></strong><span data-lake-id=\"ue0d40a99\" id=\"ue0d40a99\">true</span></p><p data-lake-id=\"u286ab641\" id=\"u286ab641\"><strong><span data-lake-id=\"u2eaf1e81\" id=\"u2eaf1e81\" style=\"color: rgb(38, 38, 38)\">示例 2：</span></strong></p><p data-lake-id=\"u5b902236\" id=\"u5b902236\"><strong><span data-lake-id=\"ud6a1f302\" id=\"ud6a1f302\">输入：</span></strong><span data-lake-id=\"u3d28635e\" id=\"u3d28635e\">n = 5<br /></span><strong><span data-lake-id=\"u34e93afc\" id=\"u34e93afc\">输出：</span></strong><span data-lake-id=\"uf02922e0\" id=\"uf02922e0\">false</span></p><p data-lake-id=\"u6025d7cf\" id=\"u6025d7cf\"><strong><span data-lake-id=\"u7083a085\" id=\"u7083a085\" style=\"color: rgb(38, 38, 38)\">示例 3：</span></strong></p><p data-lake-id=\"u6b7f5943\" id=\"u6b7f5943\"><strong><span data-lake-id=\"u1506118f\" id=\"u1506118f\">输入：</span></strong><span data-lake-id=\"uc52c1f22\" id=\"uc52c1f22\">n = 1<br /></span><strong><span data-lake-id=\"u91dca4e6\" id=\"u91dca4e6\">输出：</span></strong><span data-lake-id=\"ud49ea844\" id=\"ud49ea844\">true</span></p><p data-lake-id=\"u4e178c7e\" id=\"u4e178c7e\"><br></p><p data-lake-id=\"uec8da32a\" id=\"uec8da32a\"><span data-lake-id=\"u1b86fda4\" id=\"u1b86fda4\">将 32 个二进制位铺开来看，一个数为 4 的幂意味着有唯一的数字 1 在序列的奇数位置出现。</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%220000%200000%200000%200000%200000%200000%200000%200001%20%23%201%5Cn0000%200000%200000%200000%200000%200000%200000%200100%20%23%204%5Cn0000%200000%200000%200000%200000%200000%200001%200000%20%23%2016%5Cn0000%200000%200000%200000%200000%200000%200100%200000%20%23%2064%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22G2NmZ%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u6b5eacff\" id=\"u6b5eacff\"><span data-lake-id=\"u19aa36e1\" id=\"u19aa36e1\">所以可以利用性质 11，根据消去最后一个 1 之后结果是否为 0，可以判断数字的二进制序列中是否存在唯一的 1；另外在循环中使用 &gt;&gt;&gt; 右移操作符直到数字为 0，可以统计出 1 的初始位置。因此代码如下：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F**%5Cn%20*%20%40param%20%7Bnumber%7D%20n%5Cn%20*%20%40return%20%7Bboolean%7D%5Cn%20*%2F%5Cnvar%20isPowerOfFour%20%3D%20function(n)%20%7B%5Cn%20%20%2F%2F%20%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80%E7%9A%84%201%5Cn%20%20var%20onlyOne%20%3D%20(n%20%26%20(n%20-%201))%20%3D%3D%3D%200%5Cn%20%20%2F%2F%20%E6%B1%82%201%20%E7%9A%84%E4%BD%8D%E7%BD%AE%5Cn%20%20var%20pos%20%3D%200%2C%20temp%20%3D%20n%5Cn%20%20while%20(temp%20!%3D%3D%200)%20%7B%5Cn%20%20%20%20temp%20%3E%3E%3E%3D%201%5Cn%20%20%20%20pos%2B%2B%5Cn%20%20%7D%5Cn%20%20%2F%2F%20%E8%8B%A5%E6%9C%89%E5%94%AF%E4%B8%80%E7%9A%84%201%EF%BC%8C%E4%B8%94%201%20%E6%98%AF%E5%A5%87%E6%95%B0%EF%BC%8C%E5%88%99%E8%AE%A4%E4%B8%BA%E5%85%B6%E6%98%AF%204%20%E7%9A%84%E5%B9%82%5Cn%20%20return%20onlyOne%20%26%26%20((pos%20%26%201)%20!%3D%3D%200)%5Cn%7D%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22qrzEV%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u0cc071af\" id=\"u0cc071af\"><br></p><p data-lake-id=\"ub9baac2e\" id=\"ub9baac2e\"><span data-lake-id=\"u2fc7e924\" id=\"u2fc7e924\">复杂度分析：</span></p><p data-lake-id=\"u2ab14684\" id=\"u2ab14684\"><span data-lake-id=\"u2ac3aa1f\" id=\"u2ac3aa1f\">时间复杂度为 O(1)，解中唯一的循环，是在二进制序列上移动，移动到数字本身为 0，即可求出唯一 1 原来的位置。</span></p><p data-lake-id=\"ud107c150\" id=\"ud107c150\"><span data-lake-id=\"u24124abd\" id=\"u24124abd\">空间复杂度为 O(1)，没有额外空间开销。</span></p><p data-lake-id=\"ufe04a20b\" id=\"ufe04a20b\"><br></p><h4 data-lake-id=\"J2fBK\" id=\"J2fBK\"><span data-lake-id=\"u93981a66\" id=\"u93981a66\">461 - 汉明距离</span></h4><p data-lake-id=\"u073d15e0\" id=\"u073d15e0\"><a href=\"https://leetcode-cn.com/problems/hamming-distance\" target=\"_blank\" data-lake-id=\"u71dcd1d0\" id=\"u71dcd1d0\"><span data-lake-id=\"u4c486a4c\" id=\"u4c486a4c\">https://leetcode-cn.com/problems/hamming-distance</span></a></p><p data-lake-id=\"u5c3574ab\" id=\"u5c3574ab\"><span data-lake-id=\"u58202573\" id=\"u58202573\" style=\"color: rgb(38, 38, 38)\">两个整数之间的</span><a href=\"https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB\" target=\"_blank\" data-lake-id=\"uddb4e984\" id=\"uddb4e984\"><span data-lake-id=\"ubf7d0c2f\" id=\"ubf7d0c2f\">汉明距离</span></a><span data-lake-id=\"u3442b26c\" id=\"u3442b26c\" style=\"color: rgb(38, 38, 38)\">指的是这两个数字对应二进制位不同的位置的数目。</span></p><p data-lake-id=\"u157daa3e\" id=\"u157daa3e\"><span data-lake-id=\"ucb246755\" id=\"ucb246755\" style=\"color: rgb(38, 38, 38)\">给出两个整数 </span><span data-lake-id=\"uf55b7cfc\" id=\"uf55b7cfc\" style=\"color: rgba(var(--grey-7-rgb),1)\">x </span><span data-lake-id=\"u021bd1d1\" id=\"u021bd1d1\" style=\"color: rgb(38, 38, 38)\">和 </span><span data-lake-id=\"uc89774b0\" id=\"uc89774b0\" style=\"color: rgba(var(--grey-7-rgb),1)\">y</span><span data-lake-id=\"uad66a588\" id=\"uad66a588\" style=\"color: rgb(38, 38, 38)\">，计算它们之间的汉明距离。</span></p><p data-lake-id=\"ub30fd67d\" id=\"ub30fd67d\"><strong><span data-lake-id=\"uac1527fe\" id=\"uac1527fe\" style=\"color: rgb(38, 38, 38)\">注意：</span></strong><span data-lake-id=\"u047cfad2\" id=\"u047cfad2\" style=\"color: rgb(38, 38, 38)\">0 ≤ </span><span data-lake-id=\"u104be777\" id=\"u104be777\" style=\"color: rgba(var(--grey-7-rgb),1)\">x</span><span data-lake-id=\"u721f76a4\" id=\"u721f76a4\" style=\"color: rgb(38, 38, 38)\">, </span><span data-lake-id=\"u04bbe4d0\" id=\"u04bbe4d0\" style=\"color: rgba(var(--grey-7-rgb),1)\">y </span><span data-lake-id=\"u2a98bd6e\" id=\"u2a98bd6e\" style=\"color: rgb(38, 38, 38)\">&lt; 231.</span></p><p data-lake-id=\"ubce40f69\" id=\"ubce40f69\"><strong><span data-lake-id=\"udc56240a\" id=\"udc56240a\" style=\"color: rgb(38, 38, 38)\">示例:</span></strong></p><p data-lake-id=\"u76c95254\" id=\"u76c95254\"><strong><span data-lake-id=\"u13ad396b\" id=\"u13ad396b\">输入:</span></strong><span data-lake-id=\"u5b9aef65\" id=\"u5b9aef65\"> x = 1, y = 4<br /></span><strong><span data-lake-id=\"u3228a6a5\" id=\"u3228a6a5\">输出:</span></strong><span data-lake-id=\"u3fe78416\" id=\"u3fe78416\"> 2</span></p><p data-lake-id=\"uc0bb2333\" id=\"uc0bb2333\"><span data-lake-id=\"ubda671a0\" id=\"ubda671a0\">上面的箭头指出了对应二进制位不同的位置。</span></p><p data-lake-id=\"ue9bc9909\" id=\"ue9bc9909\"><span data-lake-id=\"u393b1977\" id=\"u393b1977\">​</span><br></p><p data-lake-id=\"ud30d1726\" id=\"ud30d1726\"><span data-lake-id=\"u36b5ee49\" id=\"u36b5ee49\">首先列出示例中两个数的二进制序列：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22bash%22%2C%22code%22%3A%220000%200000%200000%200000%200000%200000%200000%200001%5Cn0000%200000%200000%200000%200000%200000%200000%200100%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22UDOaA%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"ubcfe9919\" id=\"ubcfe9919\"><span data-lake-id=\"u1cad65ce\" id=\"u1cad65ce\">​</span><br></p><p data-lake-id=\"u74da1a36\" id=\"u74da1a36\"><span data-lake-id=\"u85e99469\" id=\"u85e99469\">很明显，只要把两数相异或，二进制位不同的位在结果中即为 1，再使用性质 11 统计结果中 1 的个数，即可得解。因此代码如下：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F**%5Cn%20*%20%40param%20%7Bnumber%7D%20x%5Cn%20*%20%40param%20%7Bnumber%7D%20y%5Cn%20*%20%40return%20%7Bnumber%7D%5Cn%20*%2F%5Cnvar%20hammingDistance%20%3D%20function(x%2C%20y)%20%7B%5Cn%20%20var%20xorRes%20%3D%20x%20%5E%20y%2C%20count%20%3D%200%5Cn%20%20while%20(xorRes%20!%3D%3D%200)%20%7B%5Cn%20%20%20%20xorRes%20%26%3D%20(xorRes%20-%201)%5Cn%20%20%20%20count%2B%2B%5Cn%20%20%7D%5Cn%20%20return%20count%5Cn%7D%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22OfGKc%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"uf8386967\" id=\"uf8386967\"><br></p><p data-lake-id=\"udd7e35d3\" id=\"udd7e35d3\"><span data-lake-id=\"u7a9651db\" id=\"u7a9651db\">时间复杂度与空间复杂度均为 O(1)。</span></p><p data-lake-id=\"uf28e563d\" id=\"uf28e563d\"><br></p><h4 data-lake-id=\"qNFub\" id=\"qNFub\"><span data-lake-id=\"u9c81d200\" id=\"u9c81d200\">1356 - 根据数字二进制下 1 的数目排序</span></h4><p data-lake-id=\"u5581b511\" id=\"u5581b511\"><a href=\"https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits\" target=\"_blank\" data-lake-id=\"u84b9e04a\" id=\"u84b9e04a\"><span data-lake-id=\"u08cd78ac\" id=\"u08cd78ac\">https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits</span></a></p><p data-lake-id=\"u11ca3c8d\" id=\"u11ca3c8d\"><span data-lake-id=\"ub16076a3\" id=\"ub16076a3\" style=\"color: rgb(38, 38, 38)\">给你一个整数数组 </span><span data-lake-id=\"u7fdac276\" id=\"u7fdac276\" style=\"color: rgba(var(--grey-7-rgb),1)\">arr</span><span data-lake-id=\"u5306c02d\" id=\"u5306c02d\" style=\"color: rgb(38, 38, 38)\"> 。请你将数组中的元素按照其二进制表示中数字 </span><strong><span data-lake-id=\"u61a98ad2\" id=\"u61a98ad2\" style=\"color: rgb(38, 38, 38)\">1 </span></strong><span data-lake-id=\"ue56b5168\" id=\"ue56b5168\" style=\"color: rgb(38, 38, 38)\">的数目升序排序。</span></p><p data-lake-id=\"u283d3ca8\" id=\"u283d3ca8\"><span data-lake-id=\"u1c5f7d67\" id=\"u1c5f7d67\" style=\"color: rgb(38, 38, 38)\">如果存在多个数字二进制中 </span><strong><span data-lake-id=\"u2ca75934\" id=\"u2ca75934\" style=\"color: rgb(38, 38, 38)\">1</span></strong><span data-lake-id=\"u53e7f36a\" id=\"u53e7f36a\" style=\"color: rgb(38, 38, 38)\"> 的数目相同，则必须将它们按照数值大小升序排列。</span></p><p data-lake-id=\"u2215dada\" id=\"u2215dada\"><span data-lake-id=\"uc3f97e5c\" id=\"uc3f97e5c\" style=\"color: rgb(38, 38, 38)\">请你返回排序后的数组。</span></p><p data-lake-id=\"ue101ce52\" id=\"ue101ce52\"><strong><span data-lake-id=\"ue746c234\" id=\"ue746c234\" style=\"color: rgb(38, 38, 38)\">示例 1：</span></strong></p><p data-lake-id=\"u06eb1016\" id=\"u06eb1016\"><strong><span data-lake-id=\"udda53cfb\" id=\"udda53cfb\">输入：</span></strong><span data-lake-id=\"u7eedd3dc\" id=\"u7eedd3dc\">arr = [0,1,2,3,4,5,6,7,8]<br /></span><strong><span data-lake-id=\"uabde005c\" id=\"uabde005c\">输出：</span></strong><span data-lake-id=\"u153103e8\" id=\"u153103e8\">[0,1,2,4,8,3,5,6,7]</span></p><p data-lake-id=\"u064bcb16\" id=\"u064bcb16\"><strong><span data-lake-id=\"uebf3cef1\" id=\"uebf3cef1\">解释：</span></strong><span data-lake-id=\"uffb82601\" id=\"uffb82601\">[0] 是唯一一个有 0 个 1 的数。<br /></span><span data-lake-id=\"u8631c518\" id=\"u8631c518\">[1,2,4,8] 都有 1 个 1。<br /></span><span data-lake-id=\"uf5866e25\" id=\"uf5866e25\">[3,5,6] 有 2 个 1。</span></p><p data-lake-id=\"u00f79758\" id=\"u00f79758\"><span data-lake-id=\"u3be7eebe\" id=\"u3be7eebe\">[7] 有 3 个 1 。<br /></span><span data-lake-id=\"ue90b2c08\" id=\"ue90b2c08\">按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]</span></p><p data-lake-id=\"u8a171db3\" id=\"u8a171db3\"><br></p><p data-lake-id=\"ufc63bfd1\" id=\"ufc63bfd1\"><span data-lake-id=\"u08e747cc\" id=\"u08e747cc\">最暴力的方法，直接调用语言自带的排序函数，对比函数中则使用性质 11 统计 value1 和 value2 二进制序列中 1 的个数，最终 1 的个数不同时按照 1 的个数升序，相同时按照数值大小升序。因此代码如下：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F**%5Cn%20*%20%40param%20%7Bnumber%5B%5D%7D%20arr%5Cn%20*%20%40return%20%7Bnumber%5B%5D%7D%5Cn%20*%2F%5Cnvar%20sortByBits%20%3D%20function(arr)%20%7B%5Cn%20%20return%20arr.sort((v1%2C%20v2)%20%3D%3E%20%7B%5Cn%20%20%20%20var%20temp1%20%3D%20v1%2C%20temp2%20%3D%20v2%2C%20count1%20%3D%200%2C%20count2%20%3D%200%5Cn%20%20%20%20while%20(temp1%20!%3D%3D%200)%20%7B%5Cn%20%20%20%20%20%20temp1%20%26%3D%20temp1%20-%201%5Cn%20%20%20%20%20%20count1%2B%2B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20while%20(temp2%20!%3D%3D%200)%20%7B%5Cn%20%20%20%20%20%20temp2%20%26%3D%20temp2%20-%201%5Cn%20%20%20%20%20%20count2%2B%2B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20count1%20%3D%3D%3D%20count2%20%3F%20v1%20-%20v2%20%3A%20count1%20-%20count2%5Cn%20%20%7D)%5Cn%7D%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22vOOj7%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u73b6d5d4\" id=\"u73b6d5d4\"><br></p><p data-lake-id=\"ub91e3a21\" id=\"ub91e3a21\"><span data-lake-id=\"ua63c8dfa\" id=\"ua63c8dfa\">复杂度分析：</span></p><p data-lake-id=\"uc71a6dc0\" id=\"uc71a6dc0\"><span data-lake-id=\"u6f43e232\" id=\"u6f43e232\">开销全部来自于系统自带的排序函数，JS 的 Array.prototype.sort 是使用快排实现的，因此复杂度与快排一致，时间复杂度为 O(nlog</span><sub><span data-lake-id=\"uc6e97bc8\" id=\"uc6e97bc8\">n</span></sub><span data-lake-id=\"ubc8e1840\" id=\"ubc8e1840\">)，空间复杂度为 O(n)。</span></p><p data-lake-id=\"u7534c2ac\" id=\"u7534c2ac\"><br></p><h4 data-lake-id=\"H7d7d\" id=\"H7d7d\"><span data-lake-id=\"ucb99e667\" id=\"ucb99e667\">总结</span></h4><p data-lake-id=\"u54ce3924\" id=\"u54ce3924\"><span data-lake-id=\"u408b7ae4\" id=\"u408b7ae4\">在上面列出的题目中，我认为 </span><a href=\"https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#ooSe4\" target=\"_blank\" data-lake-id=\"u50a515be\" id=\"u50a515be\"><span data-lake-id=\"ued293b20\" id=\"ued293b20\">78 - 子集</span></a><span data-lake-id=\"uf2537106\" id=\"uf2537106\"> 和 </span><a href=\"https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#gmonn\" target=\"_blank\" data-lake-id=\"u58295b73\" id=\"u58295b73\"><span data-lake-id=\"ub0cef712\" id=\"ub0cef712\">169 - 多数元素</span></a><span data-lake-id=\"u17a6dafc\" id=\"u17a6dafc\"> 是很有代表性的题目，这类问题的共通性在于，题干都可以拆分为多个是非问题的组合。</span><a href=\"https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#ooSe4\" target=\"_blank\" data-lake-id=\"u22d51ce2\" id=\"u22d51ce2\"><span data-lake-id=\"udb07e055\" id=\"udb07e055\">78 - 子集</span></a><span data-lake-id=\"ue751ea96\" id=\"ue751ea96\"> 是被拆分为了数组中的每一个数是否存在的问题的集合；而 </span><a href=\"https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#gmonn\" target=\"_blank\" data-lake-id=\"u2042a754\" id=\"u2042a754\"><span data-lake-id=\"ue7af41db\" id=\"ue7af41db\">169 - 多数元素</span></a><span data-lake-id=\"ud95204dd\" id=\"ud95204dd\"> 则是被拆分为统计二进制序列中每一个位置上的多数值。因此在解题时可以从这个方向进行思考。</span></p><p data-lake-id=\"u95a7a0b0\" id=\"u95a7a0b0\"><span data-lake-id=\"u10796dcd\" id=\"u10796dcd\">​</span><br></p><h3 data-lake-id=\"aZgl9\" id=\"aZgl9\"><span data-lake-id=\"ub70633e4\" id=\"ub70633e4\">位掩码</span></h3><p data-lake-id=\"u733984be\" id=\"u733984be\"><span data-lake-id=\"ue0c1e555\" id=\"ue0c1e555\">虽然本篇是从算法角度切入，但是位运算在日常开发中还有一些实用的小技巧，比如知名 JS 函数库 Lodash 中使用到的位掩码技术。</span></p><p data-lake-id=\"ua948ac3f\" id=\"ua948ac3f\"><br></p><p data-lake-id=\"ub135ef7b\" id=\"ub135ef7b\"><span data-lake-id=\"u5eb48e93\" id=\"u5eb48e93\">位掩码通常用于处理多个布尔变量的组合，在 Lodash 中，JS 对象拷贝相关函数的基础函数 baseClone 就使用了位掩码来控制不同的克隆方式。让我们直接来解读一下它的核心代码。</span></p><p data-lake-id=\"u02546a62\" id=\"u02546a62\"><span data-lake-id=\"u4365d974\" id=\"u4365d974\">​</span><br></p><p data-lake-id=\"u39466a1e\" id=\"u39466a1e\"><span data-lake-id=\"u2e247d5d\" id=\"u2e247d5d\">首先，我们需要几个预设的掩码，它们都是由一个仅有唯一 1 的二进制序列组成的（因此它们都是 2 的幂），每个二进制位代表一个开关，而后续的代码中，则可以通过某些二进制运算，来表示各种关系的不同组合：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20CLONE_DEEP_FLAG%20%3D%201%20%20%20%20%2F%2F%200001%EF%BC%9A%E6%B7%B1%E6%8B%B7%E8%B4%9D%5Cnconst%20CLONE_FLAT_FLAG%20%3D%202%20%20%20%20%2F%2F%200010%EF%BC%9A%E6%8B%B7%E8%B4%9D%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%A0%87%E5%BF%97%E4%BD%8D%5Cnconst%20CLONE_SYMBOLS_FLAG%20%3D%204%20%2F%2F%200100%EF%BC%9A%E6%8B%B7%E8%B4%9D%20Symbol%20%E7%B1%BB%E5%9E%8B%E6%A0%87%E5%BF%97%E4%BD%8D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22nYrA6%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u43b41a08\" id=\"u43b41a08\"><span data-lake-id=\"u3e5b3dfb\" id=\"u3e5b3dfb\">​</span><br></p><p data-lake-id=\"u8b21abba\" id=\"u8b21abba\"><span data-lake-id=\"u2027ea10\" id=\"u2027ea10\">然后是 cloneDeep 的代码，它调用了 baseClone，并传入了掩码 </span><code data-lake-id=\"u3f81e03f\" id=\"u3f81e03f\"><span data-lake-id=\"ue57bd93d\" id=\"ue57bd93d\">CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG</span></code><span data-lake-id=\"uf314de36\" id=\"uf314de36\">，这个表达式运算的结果是 5，也就是二进制的 0101。我们发现，通过 | 运算将两个掩码组合，就可以让两个标志位同时变成 1：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20cloneDeep(value)%20%7B%5Cn%20%20%2F%2F%20cloneDeep%20%E9%9C%80%E8%A6%81%E6%B7%B1%E5%85%8B%E9%9A%86%E5%92%8C%E5%85%8B%E9%9A%86%20Symbol%5Cn%20%20%2F%2F%201%20%7C%204%20-%3E%200001%20%7C%200100%20-%3E%200101%5Cn%20%20return%20baseClone(value%2C%20CLONE_DEEP_FLAG%20%7C%20CLONE_SYMBOLS_FLAG)%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22z6yw1%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u02276fd1\" id=\"u02276fd1\"><br></p><p data-lake-id=\"u90195d37\" id=\"u90195d37\"><span data-lake-id=\"u056b34b5\" id=\"u056b34b5\">最后找到了 baseClone 的核心代码，这里将刚才传入的 </span><code data-lake-id=\"ub6ebf2cb\" id=\"ub6ebf2cb\"><span data-lake-id=\"u9d5aa3f7\" id=\"u9d5aa3f7\">CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG</span></code><span data-lake-id=\"u0cb9a79b\" id=\"u0cb9a79b\"> 和三个掩码分别进行 &amp; 操作，突然发现这里正是用到了</span><a href=\"#XFuX7\" target=\"_blank\" data-lake-id=\"ue8f57dd5\" id=\"ue8f57dd5\"><span data-lake-id=\"u79367f73\" id=\"u79367f73\">常用性质</span></a><span data-lake-id=\"ucf670856\" id=\"ucf670856\">中的性质 3！这时会发现，我们只要将传入的掩码 bitmask 与各个标志的掩码进行 &amp; 操作，则如果 bitmask 中相应的二进制位为 1，则结果就是该掩码的值；如果 bitmask 中相应的二进制位为 0，则结果就是 0。这样就可以为每个标志位生成其对应的布尔变量，用于后续的函数判断了：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20%E5%88%9A%E6%89%8D%E6%88%91%E4%BB%AC%E4%BC%A0%E5%85%A5%E7%9A%84%E5%80%BC%E6%98%AF%201%20%7C%204%20%3D%205%5Cn%2F%2F%20%E5%9B%A0%E6%AD%A4%20isDeep%20%E7%9A%84%E5%80%BC%E5%8D%B3%E4%B8%BA%205%20%26%201%20%3D%201%5Cn%2F%2F%20%20%200101%5Cn%2F%2F%20%26%200001%5Cn%2F%2F%20------%5Cn%2F%2F%20%20%200001%5Cn%2F%2F%20%E5%8F%AF%E4%BB%A5%E5%8F%91%E7%8E%B0%EF%BC%8C%E5%BD%93%E4%BC%A0%E5%85%A5%E6%8E%A9%E7%A0%81%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%BA%8F%E5%88%97%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9B%B8%E5%BA%94%E6%A0%87%E5%BF%97%E4%BD%8D%E6%97%B6%5Cn%2F%2F%20%26%20%E6%93%8D%E4%BD%9C%E5%B0%B1%E4%BC%9A%E7%9B%B4%E6%8E%A5%E8%BF%94%E5%9B%9E%E5%BD%93%E5%89%8D%E6%A0%87%E5%BF%97%E4%BD%8D%E7%9A%84%E6%8E%A9%E7%A0%81%5Cn%2F%2F%20%E8%BF%99%E6%A0%B7%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%BF%94%E5%9B%9E%E7%9A%84%E7%BB%93%E6%9E%9C%E4%B8%BA%200%EF%BC%8C%E5%88%99%E6%84%8F%E5%91%B3%E7%9D%80%E6%8E%A9%E7%A0%81%E4%B8%AD%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9B%B8%E5%BA%94%E6%A0%87%E5%BF%97%E4%BD%8D%EF%BC%8C%E7%BB%93%E6%9E%9C%E4%B8%BA%200%20%3D%3D%20false%5Cn%2F%2F%20%E5%A6%82%E6%9E%9C%E8%BF%94%E5%9B%9E%E7%9A%84%E7%BB%93%E6%9E%9C%E5%A4%A7%E4%BA%8E%200%EF%BC%8C%E5%88%99%E6%84%8F%E5%91%B3%E7%9D%80%E6%8E%A9%E7%A0%81%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9B%B8%E5%BA%94%E6%A0%87%E5%BF%97%E4%BD%8D%EF%BC%8C%E7%BB%93%E6%9E%9C%E4%B8%BA%E4%BB%BB%E6%84%8F%E6%95%B0%E5%AD%97%EF%BC%8C%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%B8%83%E5%B0%94%E5%80%BC%E4%B8%BA%20true%5Cnfunction%20baseClone(value%2C%20bitmask%2C%20customizer%2C%20key%2C%20object%2C%20stack)%20%7B%5Cn%20%20const%20isDeep%20%3D%20bitmask%20%26%20CLONE_DEEP_FLAG%5Cn%20%20const%20isFlat%20%3D%20bitmask%20%26%20CLONE_FLAT_FLAG%5Cn%20%20const%20isFull%20%3D%20bitmask%20%26%20CLONE_SYMBOLS_FLAG%5Cn%20%20...%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22Ef269%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"0eb510c38385bc470bfff82ac79ecd62\" id=\"0eb510c38385bc470bfff82ac79ecd62\"><br></p><h3 data-lake-id=\"RTGHj\" id=\"RTGHj\"><span data-lake-id=\"uf8ddbbbd\" id=\"uf8ddbbbd\">References</span></h3><ul list=\"u621b1edf\"><li fid=\"ub6bd0ae6\" data-lake-id=\"uc950f443\" id=\"uc950f443\"><a href=\"https://www.zhihu.com/question/38206659/answer/392527806\" target=\"_blank\" data-lake-id=\"ufdca44a3\" id=\"ufdca44a3\"><span data-lake-id=\"uc0753b9a\" id=\"uc0753b9a\">位运算有什么奇技淫巧？ - 伍亦勤的回答 - 知乎</span></a></li><li fid=\"ub6bd0ae6\" data-lake-id=\"ubd2978bc\" id=\"ubd2978bc\"><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6\" target=\"_blank\" data-lake-id=\"u57b363f1\" id=\"u57b363f1\"><span data-lake-id=\"uced8e86b\" id=\"uced8e86b\">位运算符 - MDN</span></a></li><li fid=\"ub6bd0ae6\" data-lake-id=\"u425487d1\" id=\"u425487d1\"><a href=\"https://github.com/yygmind/blog/issues/31\" target=\"_blank\" data-lake-id=\"u82fe7620\" id=\"u82fe7620\"><span data-lake-id=\"udc2c255f\" id=\"udc2c255f\">【进阶4-4期】Lodash是如何实现深拷贝的 - 木易杨</span></a></li></ul>","public":1,"status":1,"likes_count":0,"read_count":0,"hits":0,"comments_count":0,"word_count":4381,"created_at":"2024-03-07T16:13:21.000Z","updated_at":"2024-03-07T17:35:26.000Z","content_updated_at":"2024-03-07T17:02:50.000Z","published_at":"2024-03-07T17:02:50.000Z","first_published_at":"2024-03-07T16:13:20.942Z","book":{"id":37879881,"type":"Book","slug":"blog","name":"Blog","user_id":125641,"description":"","creator_id":125641,"public":1,"items_count":8,"likes_count":0,"watches_count":0,"content_updated_at":"2024-03-07T17:45:56.367Z","created_at":"2023-06-05T10:04:11.000Z","updated_at":"2024-03-07T17:45:56.000Z","user":{"id":125641,"type":"User","login":"bufeidefeiyang","name":"不肥的肥羊","avatar_url":"https://cdn.nlark.com/yuque/0/2020/png/125641/1578969832542-avatar/2eebbc3e-42ea-4803-a2cf-ef73838c0c4d.png","books_count":7,"public_books_count":2,"followers_count":3,"following_count":15,"public":1,"description":"厚积薄发","created_at":"2018-05-15T16:10:45.000Z","updated_at":"2024-03-07T16:14:03.000Z","work_id":"","_serializer":"v2.user"},"namespace":"bufeidefeiyang/blog","_serializer":"v2.book"},"user":{"id":125641,"type":"User","login":"bufeidefeiyang","name":"不肥的肥羊","avatar_url":"https://cdn.nlark.com/yuque/0/2020/png/125641/1578969832542-avatar/2eebbc3e-42ea-4803-a2cf-ef73838c0c4d.png","books_count":7,"public_books_count":2,"followers_count":3,"following_count":15,"public":1,"description":"厚积薄发","created_at":"2018-05-15T16:10:45.000Z","updated_at":"2024-03-07T16:14:03.000Z","work_id":"","_serializer":"v2.user"},"tags":[],"latest_version_id":2351720718,"creator":{"id":125641,"type":"User","login":"bufeidefeiyang","name":"不肥的肥羊","avatar_url":"https://cdn.nlark.com/yuque/0/2020/png/125641/1578969832542-avatar/2eebbc3e-42ea-4803-a2cf-ef73838c0c4d.png","books_count":7,"public_books_count":2,"followers_count":3,"following_count":15,"public":1,"description":"厚积薄发","created_at":"2018-05-15T16:10:45.000Z","updated_at":"2024-03-07T16:14:03.000Z","work_id":"","_serializer":"v2.user"},"_serializer":"v2.doc_detail","doc_id":"rih5mgvkl294kred","catalog":[{"title":"前端","doc_id":"rih5mgvkl294kred"}],"body_original":"<a name=\"sVa17\"></a>\n# 位运算的算法应用\n<a name=\"Iucu7\"></a>\n### 基本介绍\n作为算法题的一个大类，位运算相关的题目常常出现在各大公司的面试/笔试题中，下面先说说位运算的基本原理。\n\n位运算使得计算机可以直接对每个比特位进行计算，效率会非常的高。\n\n在 JS 中，位运算会将操作数当作 32 位的二进制串进行计算，如果二进制串超过 32 位，则只保留最后的 32 位进行计算，如：\n```bash\n11100110111110100000000000000110000000000001 # 输入的二进制串\n            10100000000000000110000000000001 # 实际使用的二进制串\n```\n\n在 JS 中，位运算有 7 种运算符：\n\n1. 按位与（a & b）：在 a, b 的位表示中，每一个对应的位都为 1 则返回 1，否则返回 0\n```bash\n# 15 & 9 -> 9\n  0000 0000 0000 0000 0000 0000 0000 1111\n& 0000 0000 0000 0000 0000 0000 0000 1001\n  ---------------------------------------\n  0000 0000 0000 0000 0000 0000 0000 1001\n```\n\n2. 按位或（a | b）：在 a, b 的位表示中，每一个对应的位，只要有一个为 1 则返回 1，否则返回 0\n```bash\n# 15 | 9 -> 15\n  0000 0000 0000 0000 0000 0000 0000 1111\n| 0000 0000 0000 0000 0000 0000 0000 1001\n  ---------------------------------------\n  0000 0000 0000 0000 0000 0000 0000 1111\n```\n\n3. 按位异或（a ^ b）：在 a, b 的位表示中，每一个对应的位，两个不相同则返回 1，相同则返回 0\n```bash\n# 15 ^ 9 -> 6\n  0000 0000 0000 0000 0000 0000 0000 1111\n| 0000 0000 0000 0000 0000 0000 0000 1001\n  ---------------------------------------\n  0000 0000 0000 0000 0000 0000 0000 0110\n```\n\n4. 按位非（~a）：反转被操作数的位，即将每一位的 0 转为 1，1 转为 0\n```bash\n# ~15 -> -16\n~ 0000 0000 0000 0000 0000 0000 0000 1111\n  ---------------------------------------\n  1111 1111 1111 1111 1111 1111 1111 0000\n```\n\n5. 左移（a << b）：将 a 的二进制串向左移动 b 位，右边移入 0\n```bash\n# 9 << 2 -> 36\n<<  0000 0000 0000 0000 0000 0000 0000 1001\n    ---------------------------------------\n    0000 0000 0000 0000 0000 0000 0010 0100\n```\n\n6. 有符号右移（a >> b）：把 a 的二进制表示向右移动 b 位，向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。这种右移由于保留最左侧的二进制位，因此可以保留数字原本的正负符号\n```bash\n# 9 >> 2 -> 2\n>>  0000 0000 0000 0000 0000 0000 0000 1001\n    ---------------------------------------\n    0000 0000 0000 0000 0000 0000 0010 0010\n# -9 >> 2 -> -3\n>>  1111 1111 1111 1111 1111 1111 1111 0111\n    ---------------------------------------\n    1111 1111 1111 1111 1111 1111 1111 1101\n```\n\n7. 无符号右移（a >>> b）：把 a 的二进制表示向右移动 b 位，向右被移出的位被丢弃，左边空出的位全部填充为 0。这种右移由于左侧直接补 0，因此生成的数字必然是非负数\n```bash\n# 19 >>> 2 -> 4\n>>>  0000 0000 0000 0000 0000 0000 0001 0011\n     ---------------------------------------\n     0000 0000 0000 0000 0000 0000 0010 0010\n# -19 >>> 2 -> 1073741819\n>>>  1111 1111 1111 1111 1111 1111 1110 1101\n     ---------------------------------------\n     0011 1111 1111 1111 1111 1111 1111 0011\n```\n\n<a name=\"xxuVW\"></a>\n### 常用性质\n在使用位运算技巧解的算法题中，有以下这些常用的性质：\n\n1. a 与自身之间的操作\n```bash\na & a = a\na | a = a\na ^ a = 0\n```\n\n2. a 与 0 之间的操作\n```bash\na & 0 = 0\na | 0 = a\na ^ 0 = a\n```\n\n3. 按位与、按位或的还原计算\n```bash\na | ( a & b ) = a\na & ( a | b ) = a\n```\n\n4. 通过异或完成变量值交换\n```bash\na ^= b\nb ^= a\na ^= b\n```\n\n5. 判断奇偶（通过 & 1 取出最后一个二进制位以达到模 2 的效果）\n```bash\n# 位运算效率更高\na & 1 === a % 2\n```\n\n6. 比较两值是否相等（a ^ a === 0）\n```bash\na ^ b === 0\n```\n\n7. 将第 i + 1 个二进制位设为 1\n```bash\na |= 1 << i\n```\n\n8. 将第 i + 1 个二进制位设为 0\n```bash\na &= ~(1 << i)\n```\n\n9. 取出第 i + 1 个二进制位上的数值\n```bash\na & (1 << i)\n```\n\n10. 在 a 第 i + 1 个二进制位，插入 b 对应位置的二进制位\n```bash\na |= 1 << i\na & (b & 1 << i)\n```\n\n11. 删除二进制序列中最后一个值为 1 的位置\n```bash\na &= (a - 1)\n```\n\n12. 计算 a 的相反数\n```bash\n-a === ~a + 1\n```\n\n13. 保留 a 在二进制位中最后一个 1\n```bash\na &= (-a)\n```\n\n14. 生成二进制位全为 1 的数\n```bash\n~0\n```\n\n15. 保留 a 二进制序列中最后的 i - 1 位，其余补 0\n```bash\na & ((1 << i) - 1)\n```\n\n16. 将 a 二进制序列中最后 i - 1 位全部置为 0\n```bash\na & ~((1 << i) - 1)\n```\n\n17. 判断 a 的二进制序列最高位是否为 1\n```bash\na < 0 # 最高位为 1 必然是负数\n```\n\n18. 在二进制序列中，仅保留最高位的 1，其他设为 0，输出该数\n```bash\na = a | (a >> 1)\na = a | (a >> 2)\na = a | (a >> 4)\na = a | (a >> 8)\na = a | (a >> 16)\nreturn (a + 1) >> 1\n```\n\n下面，我们通过一些简单-中等的题目来体验一下位运算解题的巧妙。\n\n<a name=\"DROhD\"></a>\n### 题目\n<a name=\"dYkhm\"></a>\n#### 78 - 子集\n[https://leetcode-cn.com/problems/subsets](https://leetcode-cn.com/problems/subsets)<br />给你一个整数数组 nums，数组中的元素**互不相同**。返回该数组所有可能的子集（幂集）。<br />解集**不能**包含重复的子集。你可以按**任意顺序**返回解集。<br />**示例 1：**<br />**输入：**nums = [1,2,3]<br />**输出：**[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\n从位运算出发去思考，如果用 0 和 1 标记一个数是否存在于子集中，这样列下来，例子中的输入 [1,2,3] 就会产生下表所示的子集与 0/1 序列的关系，因此我们可以直接遍历这个 0/1 序列，去构建每个子集的数据。\n\n| 0/1序列 | 子集 | 0/1序列对应的二进制数 |\n| --- | --- | --- |\n| 000 | {} | 0 |\n| 001 | {3} | 1 |\n| 010 | {2} | 2 |\n| 011 | {2,3} | 3 |\n| 100 | {1} | 4 |\n| 101 | {1,3} | 5 |\n| 110 | {1,2} | 6 |\n| 111 | {1,2,3} | 7 |\n\n\n代码的具体实现上，可以通过 1 << nums.length 获取子集的总数；可以利用性质 9 取出相应二进制位上的数值用以构建子集的具体结构。具体的代码实现如下：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsets = function(nums) {\n  var res = [], len = nums.length\n  for (var i = 0; i < (1 << len); i++) {\n    var currSubset = []\n    for (var j = 0; j <= len; j++) {\n      if (i & (1 << j)) currSubset.push(nums[j])\n    }\n    res.push(currSubset)\n  }\n  return res\n};\n```\n\n复杂度分析：<br />时间复杂度为 O(n2n))，子集的总数为 1 << n 即 2n 种，得 O(2n)，构造每个子集时需要遍历一次原数组，得 O(n)。<br />空间复杂度为 O(n)，只有构造子集时使用的临时数组需要额外空间的开销。\n\n<a name=\"yRvpU\"></a>\n#### 136 - 只出现一次的数字\n[https://leetcode-cn.com/problems/single-number](https://leetcode-cn.com/problems/single-number)<br />给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。<br />**说明：**<br />你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？<br />**示例 1:**<br />**输入:** [2,2,1]<br />**输出:** 1<br />**示例 2:**<br />**输入:** [4,1,2,1,2]<br />**输出:** 4\n\n从位运算出发去思考，我们可以找到性质 1、2，两个相等的数异或之后为 0，一个数异或 0 等于它本身，那么将数组中所有元素相异或之后，出现 2 次的数字就会全部被约去，剩下只出现 1 次的数字，代码如下：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singleNumber = function(nums) {\n  var res = 0\n  for (var i = 0; i < nums.length; i++) {\n    res ^= nums[i]\n  }\n  return res\n};\n```\n\n复杂度分析：<br />时间复杂度为 O(n)，因为只有一次遍历数组操作。<br />空间复杂度为 O(1)，没有额外空间开销。\n\n<a name=\"nKghx\"></a>\n#### 169 - 多数元素\n[https://leetcode-cn.com/problems/majority-element](https://leetcode-cn.com/problems/majority-element)<br />给定一个大小为 _n _的数组，找到其中的多数元素。多数元素是指在数组中出现次数**大于 **⌊ n/2 ⌋ 的元素。<br />你可以假设数组是非空的，并且给定的数组总是存在多数元素。<br />**示例 1：**<br />**输入：**[3,2,3]<br />**输出：**3<br />**示例 2：**<br />**输入：**[2,2,1,1,1,2,2]<br />**输出：**2\n\n题干要求的多数元素，出现次数大于 n/2，从位运算出发去思考可以推断，如果将每一个数字都用 32 位二进制序列列出，去统计每一个二进制位是 0 多还是 1 多，则由每一位的多数元素组成的二进制序列，就可以组成最终那个多数元素的数值。代码如下：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar majorityElement = function(nums) {\n  var res = 0, len = nums.length\n  for (var i = 0; i < 32; i++) {\n    var ones = 0, zero = 0\n    for (var j = 0; j < len; j++) {\n      if (ones > len / 2 || zero > len / 2) {\n        break\n      }\n      if ((nums[j] & (1 << i)) === 0) {\n        zero++\n      } else {\n        ones++\n      }\n    }\n    if (ones > zero) res |= 1 << i\n  }\n  return res\n};\n```\n\n复杂度分析：<br />时间复杂度为 O(n)，一次枚举二进制序列上所有的位（32 位），一次遍历整个数组。<br />空间复杂度为 O(1)，没有额外空间开销。\n\n<a name=\"O1IrZ\"></a>\n#### 342 - 4 的幂\n[https://leetcode-cn.com/problems/power-of-four](https://leetcode-cn.com/problems/power-of-four)<br />给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true；否则，返回 false。<br />整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4 ^ x。<br />**示例 1：**<br />**输入：**n = 16<br />**输出：**true<br />**示例 2：**<br />**输入：**n = 5<br />**输出：**false<br />**示例 3：**<br />**输入：**n = 1<br />**输出：**true\n\n将 32 个二进制位铺开来看，一个数为 4 的幂意味着有唯一的数字 1 在序列的奇数位置出现。\n```bash\n0000 0000 0000 0000 0000 0000 0000 0001 # 1\n0000 0000 0000 0000 0000 0000 0000 0100 # 4\n0000 0000 0000 0000 0000 0000 0001 0000 # 16\n0000 0000 0000 0000 0000 0000 0100 0000 # 64\n```\n所以可以利用性质 11，根据消去最后一个 1 之后结果是否为 0，可以判断数字的二进制序列中是否存在唯一的 1；另外在循环中使用 >>> 右移操作符直到数字为 0，可以统计出 1 的初始位置。因此代码如下：\n```javascript\n/**\n * @param {number} n\n * @return {boolean}\n */\nvar isPowerOfFour = function(n) {\n  // 是否唯一的 1\n  var onlyOne = (n & (n - 1)) === 0\n  // 求 1 的位置\n  var pos = 0, temp = n\n  while (temp !== 0) {\n    temp >>>= 1\n    pos++\n  }\n  // 若有唯一的 1，且 1 是奇数，则认为其是 4 的幂\n  return onlyOne && ((pos & 1) !== 0)\n};\n```\n\n复杂度分析：<br />时间复杂度为 O(1)，解中唯一的循环，是在二进制序列上移动，移动到数字本身为 0，即可求出唯一 1 原来的位置。<br />空间复杂度为 O(1)，没有额外空间开销。\n\n<a name=\"J2fBK\"></a>\n#### 461 - 汉明距离\n[https://leetcode-cn.com/problems/hamming-distance](https://leetcode-cn.com/problems/hamming-distance)<br />两个整数之间的[汉明距离](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB)指的是这两个数字对应二进制位不同的位置的数目。<br />给出两个整数 x 和 y，计算它们之间的汉明距离。<br />**注意：**0 ≤ x, y < 231.<br />**示例:**<br />**输入:** x = 1, y = 4<br />**输出:** 2<br />上面的箭头指出了对应二进制位不同的位置。\n\n首先列出示例中两个数的二进制序列：\n```bash\n0000 0000 0000 0000 0000 0000 0000 0001\n0000 0000 0000 0000 0000 0000 0000 0100\n```\n\n很明显，只要把两数相异或，二进制位不同的位在结果中即为 1，再使用性质 11 统计结果中 1 的个数，即可得解。因此代码如下：\n```javascript\n/**\n * @param {number} x\n * @param {number} y\n * @return {number}\n */\nvar hammingDistance = function(x, y) {\n  var xorRes = x ^ y, count = 0\n  while (xorRes !== 0) {\n    xorRes &= (xorRes - 1)\n    count++\n  }\n  return count\n};\n```\n\n时间复杂度与空间复杂度均为 O(1)。\n\n<a name=\"qNFub\"></a>\n#### 1356 - 根据数字二进制下 1 的数目排序\n[https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits](https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits)<br />给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 **1 **的数目升序排序。<br />如果存在多个数字二进制中 **1** 的数目相同，则必须将它们按照数值大小升序排列。<br />请你返回排序后的数组。<br />**示例 1：**<br />**输入：**arr = [0,1,2,3,4,5,6,7,8]<br />**输出：**[0,1,2,4,8,3,5,6,7]<br />**解释：**[0] 是唯一一个有 0 个 1 的数。<br />[1,2,4,8] 都有 1 个 1。<br />[3,5,6] 有 2 个 1。<br />[7] 有 3 个 1 。<br />按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]\n\n最暴力的方法，直接调用语言自带的排序函数，对比函数中则使用性质 11 统计 value1 和 value2 二进制序列中 1 的个数，最终 1 的个数不同时按照 1 的个数升序，相同时按照数值大小升序。因此代码如下：\n```javascript\n/**\n * @param {number[]} arr\n * @return {number[]}\n */\nvar sortByBits = function(arr) {\n  return arr.sort((v1, v2) => {\n    var temp1 = v1, temp2 = v2, count1 = 0, count2 = 0\n    while (temp1 !== 0) {\n      temp1 &= temp1 - 1\n      count1++\n    }\n    while (temp2 !== 0) {\n      temp2 &= temp2 - 1\n      count2++\n    }\n    return count1 === count2 ? v1 - v2 : count1 - count2\n  })\n};\n```\n\n复杂度分析：<br />开销全部来自于系统自带的排序函数，JS 的 Array.prototype.sort 是使用快排实现的，因此复杂度与快排一致，时间复杂度为 O(nlogn)，空间复杂度为 O(n)。\n\n<a name=\"H7d7d\"></a>\n#### 总结\n在上面列出的题目中，我认为 [78 - 子集](https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#ooSe4) 和 [169 - 多数元素](https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#gmonn) 是很有代表性的题目，这类问题的共通性在于，题干都可以拆分为多个是非问题的组合。[78 - 子集](https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#ooSe4) 是被拆分为了数组中的每一个数是否存在的问题的集合；而 [169 - 多数元素](https://www.yuque.com/bufeidefeiyang/frontend/qyclgd#gmonn) 则是被拆分为统计二进制序列中每一个位置上的多数值。因此在解题时可以从这个方向进行思考。\n\n<a name=\"aZgl9\"></a>\n### 位掩码\n虽然本篇是从算法角度切入，但是位运算在日常开发中还有一些实用的小技巧，比如知名 JS 函数库 Lodash 中使用到的位掩码技术。\n\n位掩码通常用于处理多个布尔变量的组合，在 Lodash 中，JS 对象拷贝相关函数的基础函数 baseClone 就使用了位掩码来控制不同的克隆方式。让我们直接来解读一下它的核心代码。\n\n首先，我们需要几个预设的掩码，它们都是由一个仅有唯一 1 的二进制序列组成的（因此它们都是 2 的幂），每个二进制位代表一个开关，而后续的代码中，则可以通过某些二进制运算，来表示各种关系的不同组合：\n```javascript\nconst CLONE_DEEP_FLAG = 1    // 0001：深拷贝\nconst CLONE_FLAT_FLAG = 2    // 0010：拷贝原型链标志位\nconst CLONE_SYMBOLS_FLAG = 4 // 0100：拷贝 Symbol 类型标志位\n```\n\n然后是 cloneDeep 的代码，它调用了 baseClone，并传入了掩码 `CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG`，这个表达式运算的结果是 5，也就是二进制的 0101。我们发现，通过 | 运算将两个掩码组合，就可以让两个标志位同时变成 1：\n```javascript\nfunction cloneDeep(value) {\n  // cloneDeep 需要深克隆和克隆 Symbol\n  // 1 | 4 -> 0001 | 0100 -> 0101\n  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG)\n}\n```\n\n最后找到了 baseClone 的核心代码，这里将刚才传入的 `CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG` 和三个掩码分别进行 & 操作，突然发现这里正是用到了[常用性质](#XFuX7)中的性质 3！这时会发现，我们只要将传入的掩码 bitmask 与各个标志的掩码进行 & 操作，则如果 bitmask 中相应的二进制位为 1，则结果就是该掩码的值；如果 bitmask 中相应的二进制位为 0，则结果就是 0。这样就可以为每个标志位生成其对应的布尔变量，用于后续的函数判断了：\n```javascript\n// 刚才我们传入的值是 1 | 4 = 5\n// 因此 isDeep 的值即为 5 & 1 = 1\n//   0101\n// & 0001\n// ------\n//   0001\n// 可以发现，当传入掩码的二进制序列中存在相应标志位时\n// & 操作就会直接返回当前标志位的掩码\n// 这样，如果返回的结果为 0，则意味着掩码中不存在相应标志位，结果为 0 == false\n// 如果返回的结果大于 0，则意味着掩码中存在相应标志位，结果为任意数字，转换为布尔值为 true\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  const isDeep = bitmask & CLONE_DEEP_FLAG\n  const isFlat = bitmask & CLONE_FLAT_FLAG\n  const isFull = bitmask & CLONE_SYMBOLS_FLAG\n  ...\n}\n```\n\n<a name=\"RTGHj\"></a>\n### References\n\n- [位运算有什么奇技淫巧？ - 伍亦勤的回答 - 知乎](https://www.zhihu.com/question/38206659/answer/392527806)\n- [位运算符 - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6)\n- [【进阶4-4期】Lodash是如何实现深拷贝的 - 木易杨](https://github.com/yygmind/blog/issues/31)\n","properties":{"title":"位运算的算法应用","urlname":"rih5mgvkl294kred","date":"2024-03-08 00:13:21","updated":"2024-03-08 01:35:26","author":"不肥的肥羊","description":"位运算的算法应用基本介绍作为算法题的一个大类，位运算相关的题目常常出现在各大公司的面试/笔试题中，下面先说说位运算的基本原理。位运算使得计算机可以直接对每个比特位进行计算，效率会非常的高。在 JS 中，位运算会将操作数当作 32 位的二进制串进行计算，如果二进制串超过 32 位，则只保留最后的..."},"updated":1709832926000,"docPath":"./docs/docs"}